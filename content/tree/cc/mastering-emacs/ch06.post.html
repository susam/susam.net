<!-- date: 2023-12-28 -->
<!-- title: Notes on Mastering Emacs: Chapter 6: The Practicals of Emacs -->
<!-- tag: Emacs, Technology, Book, Meetup -->
<!-- key: nqgkb -->
<!-- import: extra.css -->
<p>
  The following notes were taken while discussing Chapter 6 of the
  book <em>Mastering Emacs</em> by Mickey Petersen (2022 edition) in
  <a href="./{{ index }}">book discussion group meetings</a>.
</p>
<p>
  An index of notes for all chapters are available
  at <a href="notes.html">notes.html</a>.
</p>
{{ toc }}
<h2 id="exploring-emacs">Exploring Emacs</h2>
<p>
  The book suggests the following techniques to explore Emacs:
</p>
<ul>
  <li>
    <p>
      Reading the manual.  For example, type <code>M-x info RET</code>
      or <code>C-h i</code>, then navigate to the <code>Emacs</code>
      hyperlink, then type <code>C-s version control RET</code> and
      then navigate to the node named <code>Version Control</code> to
      read the corresponding manual.
    </p>
    <p>
      Note that the section named <em>The Info Manual</em> in Chapter
      3 offers more alternatives to reach a specific node in a more
      straightforward manner.  For example, <code>C-h i m emacs RET m
      Version Control RET</code> accomplishes the same result.
      Alternatively, <code>C-h R emacs RET m Version Control
      RET</code> also accomplishes the same result.  Yet another way
      to accomplish the same result is to evaluate the Elisp
      expression <code>(info "(emacs)Version Control")</code>.  See
      section <a href="ch03.html#info">Info</a> in chapter 3 notes for
      more details.
    </p>
    <p>
      Yet another way to explore the manual is to use
      the <code>info-apropos</code> command.  For example,
      type <code>M-x info-apropos RET version control RET</code> to
      find manuals which have the string "version control" in them.
    </p>
  </li>
  <li>
    <p>
      Using apropos.  For example, type <code>C-h d version control
      RET</code> to search for all symbols whose documentation string
      contains the specified pattern.  Then type <code>C-h a ^vc-
      RET</code> to search for all commands that match this pattern.
      This is a convenient way to list the vc commands.  Also, see
      section <a href="ch03.html#apropos">Apropos</a> in chapter 3
      notes for more details.
    </p>
  </li>
  <li>
    <p>
      Exploring prefix keys.  For example, type <code>C-x v C-h</code>
      to list all key sequences bound to the prefix key <code>C-x
      v</code>.  This is in fact a convenient way to list all the vc
      key bindings.  Also, see section
      <a href="ch03.html#discovering-and-remembering-keys">Discovering
      and Remembering Keys</a> in chapter 3 notes for more details.
    </p>
  </li>
  <li>
    <p>
      Describe what a key does.  For example, type <code>C-h k</code>
      followed by <code>C-x v v</code> to see the command that is
      bound to the latter key sequence as well as its documentation
      string along with other details like the keymap where the key
      binding is found, the file where the command is defined, other
      key bindings for the same command, etc.  See
      section <a href="ch03.html#describe">Describe</a> in chapter 3
      notes for some more details.
    </p>
  </li>
  <li>
    <p>
      Describe commands.  For example, type <code>C-h f vc-dir
      RET</code> to see information about the <code>vc-dir</code>
      command.  See section <a href="ch03.html#describe">Describe</a>
      in chapter 3 notes for some more details.
    </p>
  </li>
  <li>
    <p>
      Find mode commands.  Type <code>C-h m</code> to see the
      documentation strings of the current major mode and minor modes.
      A brief summary of the minor modes is shown first, followed by
      the major mode description.  This is followed by documentation
      strings of the minor modes separated by page breaks (the form
      feed character that is rendered as <code>^L</code> in Emacs).
      See section <a href="ch03.html#describe">Describe</a> in chapter
      3 notes for some more details.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-X</code> to run
      <code>execute-extended-command-for-buffer</code> which executes
      commands that are relevant to the current buffer.  While
      offering completions, it limits the completions to commands
      relevant to the current buffer.  See
      section <a href="ch03.html#m-x-execute-extended-command-for-buffer">M-X:
      Execute Extended Command for Buffer</a> of chapter 3 notes for
      more details.
    </p>
  </li>
</ul>
<h2 id="project-management">Project Management</h2>
<p>
  Emacs comes with a project management package
  named <code>project.el</code> which offers commands to operate on
  projects.  When we use a project management command like <code>C-x p
  f</code> to visit a file in the current project, this package
  automatically detects the top-level directory of the project by
  checking parent directories for version control system artifacts
  (e.g. <code>.git</code> directory) and presents files within that
  top-level directory as autocomplete options.
</p>
<p>
  The following complete key sequences demonstrate the package
  management commands mentioned in the book:
</p>
<ul>
  <li>
    <p>
      <code>C-x p p ... TAB RET ~/git/foo/ RET f README.md</code>:
      This awkward key sequence discovers a new project directory
      at <code>~/git/foo/</code> and then finds the file
      named <code>README.md</code> in it.  As soon as the key
      sequence <code>f</code> is typed above, the new project
      directory is discovered and added
      to <code>~/.emacs.d/projects</code> which is where the list of
      known projects is saved.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p p bar TAB RET f Makefile</code>: Assuming there is
      already a known project with <code>bar</code> in its name
      (say, <code>~/git/bar/</code>) that was discovered earlier, this
      key sequence switches to that project and finds the file named
      in <code>Makefile</code> in it.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p f dev/build.sh RET</code>: Find file
      named <code>dev/build.sh</code> in the current project.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p f build TAB RET</code>: Same as above
      if <code>dev/build.sh</code> is the only match
      for <code>build</code>.  Otherwise, it presents all files in the
      current project containing <code>build</code> anywhere in its
      path name as autocomplete options.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p f bar TAB RET build TAB RET</code>: When we
      type <code>C-x p f</code> while visiting a file that does not
      belong to any project, then its prompts for a project name.  In
      this example, we type <code>bar TAB RET</code> to automatically
      expand it to a known project name such
      as <code>~/git/bar/</code> and enter it.  Then we
      type <code>build TAB RET</code> to automatically expand it to a
      file name such as <code>dev/build.sh</code> and enter it.
    </p>
    <p>
      It is worth noting a general point that whenever we invoke a
      project command while visiting a file that does not belong to a
      project, the project command prompts for the project name.
      After we enter the project name, the project command runs on our
      chosen project.  This general point applies to other project
      commands that come later in this list.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p b Makefile RET</code>: Switch to a buffer
      named <code>Makefile</code> in the current project.  While
      entering the buffer name when <code>TAB</code> is typed,
      completion options present buffer names from the current project
      only.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p k yes RET</code>: Kill all buffers belonging to the
      current project.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p g ^key\&gt; RET</code>: Find all matches for the
      regular expression <code>^key\&gt;</code> in the current
      project.  The matches are found in all files in the project
      regardless of whether they are currently open in Emacs or not.
      The matches are displayed in a buffer named <code>*xref*</code>.
      We can navigate this buffer using key sequences
      like <code>n</code>, <code>p</code>, etc.  Type
      <code>C-h m</code> in this buffer to see a list of key sequences
      supported in this buffer.  As we navigate this buffer and go
      from one match to another using <code>n</code>, <code>p</code>,
      etc. the files containing the match are loaded in a split window
      automatically with the matching lines automatically centred in
      that window.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p r ^key\&gt; RET =key= RET</code>: Find all matches
      for the regular expression pattern <code>^key\&gt;</code> in the
      current project and replace them with <code>=key=</code>.  The
      modified files are not automatically saved though.  They needed
      to be saved later explicitly.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p c RET</code>: Compiles the current project.  By
      default, it offers as <code>make -f</code> as the command to be
      run in the project root.  If a specific <code>make</code> target
      needs to be executed or if another command needs to be executed,
      then the default command offered may be edited before
      typing <code>RET</code>.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p v</code>: Runs VC-Dir in the current project's root
      which in turn shows version control status for the project root.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p s</code>: Start shell in the current project's root
      directory.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p d RET</code>: Start Dired in the current project's
      root directory.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p D</code>: Same as above.
    </p>
  </li>
  <li>
    <p>
      <code>C-x p d doc/tutorial/ RET</code>: Start Dired in
      the <code>doc/tutorial/</code> subdirectory in the current
      project.
    </p>
  </li>
</ul>
<p>
  There are several more project management key bindings.
  Type <code>C-x p C-h</code> to see a complete list of them.
</p>
<h2 id="xref">Xref</h2>
<p>
  Xref provides a generic framework to support commands for
  cross-referencing in Emacs.  While there are several ways to set it
  up and configure it, the book mentions a particular way to set it up
  using a couple of external tools.  The next two subsections discuss
  the setup work involved before we can use Xref in a modern way.  The
  remaining subsections discuss how to use Xref.
</p>
<h3 id="xref-setup">Xref Setup</h3>
<p>
  By default when we try to look up a definition of an identifier in,
  say, a C file or Python file, by typing <code>M-.</code>, it
  presents a minibuffer for us to select a tags table file (typically
  named <code>TAGS</code>).  This requires setting up
  a <code>TAGS</code> file with a tool like <code>ctags</code>.  The
  book, however, does not explore this method for good reason.
  Typically the <code>TAGS</code> file needs to be created with a tool
  like <code>ctags</code> or <code>etags</code> for every project we
  work on.  This file contains an index of names found in source code
  files.  We need to periodically update it as the code of our
  projects evolve, so that this index remains up-to-date.  For a long
  time, this was the only way to maintain an index of the names found
  in a source code, so that we could perform cross-referencing in
  editors like Vim and Emacs.  Relying on a tool
  like <code>grep</code> to search the code on the fly was deemed to
  be quite slow.  However, with modern, fast hardware we do not have
  to work like this anymore.  Further, there are search tools
  like <code>ag</code> and <code>rg</code> which are extremely fast.
  Given these modern developments, there are simpler ways to set up
  cross-referencing in Emacs.
</p>
<p>
  The book suggets installing an external package
  named <code>dumb-jump</code>.  It can be installed from MELPA with
  the key sequence <code>M-x package-install dumb-jump RET</code>.
  See <a href="https://github.com/jacktasia/dumb-jump">github.com/jacktasia/dumb-jump</a>
  for more details about this package.  After installing this package,
  add the following code to the Emacs initialisation file:
</p>
<pre><code>(add-hook 'xref-backend-functions #'dumb-jump-xref-activate)</code></pre>
<p>
  Here is a minimal Elisp code that sets up <code>dumb-jump</code>
  from scratch and configures it as mentioned above:
</p>
<pre>
<code>(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))
(dolist (package '(dumb-jump))
  (unless (package-installed-p package)
    (package-install package)))
(add-hook 'xref-backend-functions #'dumb-jump-xref-activate)</code>
</pre>
<p>
  The above code configures Emacs to use MELPA, retrieve the latest
  list of packages available there, install <code>dumb-jump</code>
  from it, as well as set up a hook to activate it automatically when
  we use certain Xref commands.
</p>
<h3 id="search-tools-for-xref">Search Tools for Xref</h3>
<p>
  Once Xref is set up with <code>dumb-jump</code> as explained in the
  previous section, open a source code file (say, a C file or a Python
  file), move the cursor over to some identifier and
  type <code>M-.</code> to search that identifier in your environment.
  By default, it searches for the identifier in files of the same type
  found under the home directory with a tool like <code>ag</code>,
  <code>rg</code> or <code>grep</code> (the first one it finds).
  There is an exception to this rule though.  If
  neither <code>ag</code> nor <code>rg</code> is found and only GNU
  grep is found, then typing <code>M-.</code> on an indentifier
  searches the identifier in all files in the home directory (as
  opposed to searching for files of a specific type).  If BSD grep is
  found instead, then this is not a problem and only files of the
  current type is searched for the identifier.
</p>
<p>
  Further, while looking up definitions within a Git repository, this
  package invokes the <code>git grep</code> command to restrict
  searches to the repository directory.
</p>
<p>
  Let us now look at a few examples of the actual search commands that
  are executed under the hood when we type <code>M-.</code>.
</p>
<p>
  If neither <code>ag</code> nor <code>rg</code> is installed and we
  only have <code>grep</code> on our system, typing <code>M-.</code>
  while the cursor is on an identifier named <code>foo</code> in a
  Python file leads to the execution of a command like this when BSD
  grep is found:
</p>
<pre><code>grep -REn --include '*.py' -e '\s*\bfoo\s*=[^=\n]+' -e 'def\s*foo\b\s*\(' -e 'class\s*foo\b\s*\(?' /Users/susam</code></pre>
<p>
  If GNU grep is found instead, then all files (not
  just <code>*.py</code> files) are searched with a command like this:
</p>
<pre><code>grep -rEn -e '[[:space:]]*\bfoo[[:space:]]*=[^=\n]+' -e 'def[[:space:]]*foo\b[[:space:]]*\(' -e 'class[[:space:]]*foo\b[[:space:]]*\(?' /home/susam</code></pre>
<p>
  If <code>rg</code> is the only additional search tool installed,
  then the following command is executed:
</p>
<pre><code>rg --color never --no-heading --line-number -U --pcre2 --type py '\s*\bfoo\s*=[^=\n]+|def\s*foo\b\s*\(|class\s*foo\b\s*\(?' /home/susam</code></pre>
<p>
  If <code>ag</code> is installed, then the following command is
  executed:
</p>
<pre><code>ag --nocolor --nogroup --python '\s*\bfoo\s*=[^=\n]+|def\s*foo\b\s*\(|class\s*foo\b\s*\(?' /home/susam</code></pre>
<p>
  When we type <code>M-.</code> in a file that belongs to a Git
  repository, only the repository directory is searched with a command
  like this:
</p>
<pre><code>git grep --color=never --line-number --untracked -E '\s*\bfoo\s*=[^=\n]+|def\s*foo\b\s*\(|class\s*foo\b\s*\(?' -- /home/susam/repo/*.py</code></pre>
<p>
  The book makes a mention of <code>rg</code> and remarks about the
  impressive speed with which it searches the file system.  I
  recommend it too.  Since the <code>M-.</code> command may search the
  whole home directory, if the home directory is very large, having a
  fast search tool like <code>rg</code> or <code>ag</code> makes a
  significant difference.  For example what could normally take 10 to
  20 seconds to search using <code>grep</code> might only take a
  second or two with <code>rg</code> or <code>ag</code>.  I
  use <code>M-.</code> with <code>rg</code>.
</p>
<h3 id="four-most-common-xref-commands">Four Most Common Xref Commands</h3>
<p>
  The book mentions the following commands as the four most common
  commands we should know about:
</p>
<ul>
  <li>
    <p>
      <code>M-.</code>: Find definitions of the identifier at point.
      If a unique definition is found, then the file containing the
      definition is automatically opened and the definition is centred
      in the window.  If multiple possible candidates are found, then
      they are displayed in an Xref buffer that we can navigate using
      key sequences like <code>n</code> or <code>p</code>.  As we
      navigate the Xref buffer, the source of each match is
      automatically opened in a split window and the matching line is
      centred.
    </p>
  </li>
  <li>
    <p>
      <code>M-,</code>: Go back to where <code>M-.</code> was last
      invoked.
    </p>
  </li>
  <li>
    <p>
      <code>M-? foo RET ~/git/foo/ RET</code>: Find all occurrences of
      the word <code>foo</code> in files of the same type as the
      current file in the project directory <code>~/git/foo/</code>.
      It does not restrict the search to definitions only.  If the
      current file belongs to a project already, then we could simply
      type <code>M-? foo RET</code>.  In fact, since the input to the
      minibuffer prompt is the identifier at the point by default, we
      could simply type <code>M-? RET</code> to search for the current
      identifier in the current project.
    </p>
  </li>
  <li>
    <p>
      <code>C-M-. foo RET</code>: Find symbols matching the given
      pattern.  Although the documentation mentions that this supports
      regular expressions, it seemed to treat the given pattern as an
      identifier and searched for that identifier literally.  In fact,
      the <code>rg</code> commands that were executed under the hood
      were exactly the same as the ones executed by <code>M-.</code>.
      Thus with <code>dumb-jump</code> enabled, both <code>M-.</code>
      and <code>C-M-.</code> behave similarly.  The only difference is
      that <code>M-.</code> searches for the identifier at the point
      whereas <code>C-M-.</code> searches for the identifier we enter
      at the minibuffer as input.
    </p>
  </li>
</ul>
<p>
  When multiple cross-references are displayed in the Xref buffer, we
  can use the following key sequences to work with the Xref buffer.
</p>
<ul>
  <li>
    <p>
      <code>n</code>: Move to the next cross-reference.  The source of
      the cross-reference is automatically displayed in another
      window.
    </p>
  </li>
  <li>
    <p>
      <code>n</code>: Move to the previous cross-reference.  The source
      of the cross-reference is automatically displayed in another
      window.
    </p>
  </li>
  <li>
    <p>
      <code>.</code>: Same as <code>n</code>.
    </p>
  </li>
  <li>
    <p>
      <code>,</code>: Same as <code>p</code>.
    </p>
  </li>
  <li>
    <p>
      <code>RET</code>: Jump to the source of the current
      cross-reference.
    </p>
  </li>
  <li>
    <p>
      <code>TAB</code>: Hide Xref buffer and jump to the source.
    </p>
  </li>
  <li>
    <p>
      <code>C-o</code>: Show the source of the cross-reference at
      point in a separate window but keep the point in the Xref
      window.  This is useful when we navigate the Xref buffer using
      normal Emacs commands like <code>C-p</code>, <code>C-n</code>,
      <code>C-s</code>, etc.  While navigating the Xref buffer with
      these normal Emacs commands, the source of the cross-references at
      the point is not automatically displayed.  The key
      sequence <code>C-o</code> helps us to display the cross-reference
      at the point in this case.
    </p>
  </li>
  <li>
    <p>
      <code>r</code>: Perform search and replace in the names of the
      references displayed in the Xref buffer.  However, I did not
      find this to be working successfully
      with <code>dumb-jump</code>.  Any attempt to use this command
      with <code>dumb-jump</code> always led me to the following
      error: <code>No suitable matches here</code>.  This key sequence
      does work as expected when Xref is invoked from Dired as going
      to be explained in the next section.
    </p>
  </li>
</ul>
<h3 id="xref-and-dired">Xref and Dired</h3>
<p>
  Here are some key sequences that demonstrate how we can use Xref
  with Dired.
</p>
<ul>
  <li>
    <code>C-x d RET</code>: Edit current directory using Dired.
  </li>
  <li>
    <code>n</code>: Move to the next line.  <code>C-n</code> also
    works.
  </li>
  <li>
    <code>p</code>: Move to the previous line.  <code>C-p</code> also
    works.
  </li>
  <li>
    <code>m</code>: Mark the file or subdirectory at the point.
  </li>
  <li>
    <code>u</code>: Unmark the file or subdirectory at the point.
  </li>
  <li>
    <code>A f.. RET</code>: Find all matches for the regular
    expression <code>f..</code> in the marked files and
    subdirectories.  The matches are always displayed in an Xref
    buffer, even when a single match is found.
  </li>
  <li>
    <code>Q f.. RET bar RET</code>: Find all matches for the regular
    expression <code>f..</code> in the marked files and subdirectories
    and replace them with <code>bar</code>.
  </li>
</ul>
<h2 id="working-with-log-files">Working with Log Files</h2>
<p>
  In this section of the book, it discusses a set of commands that are
  useful for working with log files.  Note that some of these commands
  have been already introduced in the previous chapters.  The
  following list presents the commands discussed in this section of
  the book:
</p>
<ul>
  <li>
    <code>C-x C-f</code>: Find a file.
  </li>
  <li>
    <code>C-x C-r</code>: Find file and open in read-only mode.
  </li>
  <li>
    <code>C-x C-q</code>: Toggle read-only mode.
  </li>
  <li>
    <code>M-x flush-lines RET b.. RET</code>: Delete lines in region
    that match the regular expression <code>b..</code>.  If no region
    is active, then delete matching lines between the point and end of
    buffer.  The deleted lines are not copied to kill ring.  See
    section <a href="ch05.html#deleting-and-keeping-lines">Deleting
    and Keeping Lines</a> of chapter 5 notes for more details.
  </li>
  <li>
    <code>M-x keep-lines RET b.. RET</code>: Keep lines in region that
    match the regular expression <code>b..</code> and delete the rest.
    If no region is active, then keep matching lines between the point
    and end of buffer and delete the rest.  The deleted lines are not
    copied to kill ring.  See section
    <a href="ch05.html#deleting-and-keeping-lines">Deleting and
    Keeping Lines</a> of chapter 5 notes for more details.
  </li>
  <li>
    <code>M-s o b.. RET</code>: Show all lines in the current buffer
    matching the regular expression <code>b..</code>.  If the region
    is active, then show matching lines from the region only.  The
    matches are shown in a new Occur mode buffer.  The book makes a
    special mention that we can run <code>M-s o</code> on an Occur
    mode buffer to filter it further and get the results in another
    Occur mode buffer.  See section
    <a href="ch04.html#occur-mode">Occur Mode</a> in chapter 4 notes
    for more details.
  </li>
</ul>
<h2 id="highlighting">Highlighting</h2>
<p>
  Section <em>Working with Log Files</em> of Chapter 6 of the book
  also introduces highlighting commands that can be very useful for
  highlighting certain strings in the log file.  The highlighting
  commands are demonstrated below with an example.
</p>
<ol>
  <li>
    <p>
      First create a buffer with the following content.
    </p>
<pre>
<code>foo bar baz
Foo Bar Baz
FOO BAR BAZ
foo  bar  baz
Foo  Bar  Baz
FOO  BAR  BAZ</code>
</pre>
  </li>
  <li>
    <p>
      Now type <code>M-s h p f.. SPC b.. RET RET</code> to highlight
      the phrases matching the regular expression <code>f.. b..</code>
      in a case-insensitive and whitespace-insensitive manner.  A
      total of six matches will be highlighted because the first two
      words and the whitespace between them in all lines match this
      phrase pattern when we ignore the case of the words and the
      amount of whitespace.  The second <code>RET</code> is meant to
      accept the default face offered to us for highlighting.
    </p>
  </li>
  <li>
    <p>
      Now type <code>M-s h p b.z RET RET</code> to highlight the
      phrases matching the regular expression <code>b.z</code>.  Again
      we select the default face offered to us for highlighting.  At
      this point, we should see two sets of highlighting in two
      different faces.
    </p>
  </li>
  <li>
    <p>
      Now move the cursor to one of the first set of highlights and
      type <code>M-s h u RET</code>.  Those highlights will be
      unhighlighted.  The <code>RET</code> key accepts the default
      unhighlighting pattern offered to us.  It happens to be the
      pattern with which the highlight under the cursor was
      highlighted.  That is why this key sequence ends up
      unhighlighting the highlight under the cursor.
    </p>
    <p>
      If the cursor were not over a highlgiht, then the default
      unhighlighting pattern offered to us would have been the pattern
      we used for the last highlight.  In that case, we could
      type <code>M-s h u f.. b.. RET</code> to explicitly specify the
      unhighlighting pattern.
    </p>
  </li>
  <li>
    <p>
      Now type <code>M-s h u RET</code> again to remove the second set
      of highlights too.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-s h p F.. SPC B.. RET RET</code> to perform a
      case-sensitive but whitespace-insensitive highlighting.  When
      there is an uppercase letter in the pattern, the highlighting
      becomes case-sensitive.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-s h u RET</code> to remove the previous
      highlighting.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-s h r f.. SPC b.. RET RET</code> to perform a
      case-insensitive but whitespace-sensitive highlighting.  This
      time, there are only three matches from the first three lines.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-s h u RET</code> to remove the previous
      highlighting.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-s h r F.. SPC B.. RET RET</code> to perform a
      case-sensitive and whitespace-sensitive highlighting.  The
      matching strings are found in the second and third lines.
    </p>
  </li>
  <li>
    <p>
      Move the cursor to lowercase <code>bar</code> and type <code>M-s
      h .</code> to highlight symbol at point.  All six occurrences of
      this symbol are highlighted in a case-insensitive manner because
      the symbol at point is written in all lowercase.
    </p>
  </li>
  <li>
    <p>
      Move the cursor to <code>Baz</code> and type <code>M-s h
      .</code> to highlight symbol at point.  Only two occurrences of
      this symbol get highlighted.  The highlighted symbols match the
      symbol <code>Baz</code> exactly (case-sensitive match).  The
      highlighting is done in case-sensitive manner because the symbol
      at point has at least one uppercase letter.
    </p>
  </li>
</ol>
<h2 id="auto-revert-mode">Auto-Revert Mode</h2>
<p>
  The following steps demonstrate how to use
  the <code>revert-buffer</code> command and then how to
  use <code>auto-revert-mode</code>.
</p>
<ol>
  <li>
    <p>
      In a terminal, run the following command:
    </p>
    <pre><code>: &gt; /tmp/log.txt &amp;&amp; while true; do date &gt;&gt; /tmp/log.txt; sleep 1; done</code></pre>
    <p>
      You could use <code>ansi-term</code> within Emacs too as the
      terminal if you are familiar with it.
    </p>
  </li>
  <li>
    <p>
      Now within Emacs, type <code>C-x C-f /tmp/log.txt RET</code>.
    </p>
  </li>
  <li>
    <p>
      Wait for a few seconds and type <code>M-x revert-buffer RET yes
      RET</code> to update the buffer with the latest content of the
      file from the file system.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-x auto-revert-mode RET</code> to enable automatic
      update of the buffer as the file changes on the file system.
      Note that this reloads the entire file whenever a change is
      detected, so this could be inefficient while working with very
      large files.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-&gt;</code> to go to the end of the buffer.  This
      moves the cursor to the end of the buffer.  Doing this ensures
      that as the buffer is automatically updated, the cursor
      automatically keeps moving to the end of the file.
    </p>
  </li>
  <li>
    <p>
      Terminate the command of step 1 and run this command in a
      terminal:
    </p>
    <pre><code>echo hello &gt; /tmp/log.txt</code></pre>
    <p>
      The content of the buffer should now automatically truncate and
      update to just the text <code>hello</code>.
    </p>
  </li>
  <li>
    <p>
      Run the command in step 1 again and confirm that the content of
      the buffer in Emacs gets updated automatically.
    </p>
  </li>
  <li>
    <p>
      Type <code>M-x auto-revert-mode RET</code> to disable automatic
      update of the buffer.
    </p>
  </li>
</ol>
<h2 id="auto-revert-tail-mode">Auto Revert Tail Mode</h2>
<p>
  The mode named <code>auto-revert-tail-mode</code> is similar
  to <code>auto-revert-mode</code>.  However,
  unlike <code>auto-revert-mode</code> which reloads the entire file
  on every update, the <code>auto-revert-tail-mode</code> only follows
  the tail of the buffer and appends any new text found to the buffer.
  The following steps demonstrate this:
</p>
<ol>
  <li>
    <p>
      Like in the previous section, run the following command:
    </p>
    <pre><code>: &gt; /tmp/log.txt &amp;&amp; while true; do date &gt;&gt; /tmp/log.txt; sleep 1; done</code></pre>
  </li>
  <li>
    <p>
      Type <code>M-x auto-revert-tail-mode RET</code>.  Note that this
      command follows the tail of the file only.  It does not reload
      the entire file.  This can be confirmed with the next step.
    </p>
  </li>
  <li>
    <p>
      Terminate the command of step 1 and run this command in a
      terminal:
    </p>
    <pre><code>echo hello &gt; /tmp/log.txt</code></pre>
    <p>
      The buffer for this file in Emacs should automatically update to
      show the text <code>hello</code> at the bottom.  But notice all
      the earlier text remains intact.  The earlier text does not
      disappear from the buffer because Emacs does not reload the
      entire file when <code>auto-revert-tail-mode</code> is enabled.
    </p>
  </li>
  <li>
    <p>
      Run the command in step 1 again and confirm that the content of
      the buffer begins to get updated automatically again.
    </p>
  </li>
  <li>
    <p>
      As of Emacs 28.2, unfortunately running <code>M-x
      auto-revert-tail-mode RET</code> is not sufficient to disable
      automatic updates in the buffer.  This command does disable the
      mode but the buffer continues to be updated everytime the file
      changes.  This is very likely a bug in this mode.
    </p>
    <p>
      As a workaround, disabling <code>auto-revert-mode</code> ends up
      stopping the auto-update behaviour.  There are two ways to do
      this.  You could type <code>M-x auto-revert-mode RET</code>
      twice: once to enable it and a second time to disable it.
      Alternatively, just simply type <code>C-0 M-x auto-revert-mode
      RET</code> which invokes the mode with a prefix argument of zero
      which ends up disabling the mode.
    </p>
  </li>
</ol>
<h2 id="browsing-tarballs">Browsing Tarballs</h2>
<p>
  The following steps demonstrate how we can not only browse a tarball
  but also edit files in it and save them back to the tarball.
</p>
<ol>
  <li>
    <p>
      First, create a directory of text files with the following shell
      commands:
    </p>
<pre>
<code>mkdir -p foo/bar/baz/
echo hello foo &gt; foo/foo.txt
echo hello bar &gt; foo/bar/bar.txt
echo hello baz &gt; foo/bar/baz/baz.txt
tar -caf /tmp/foo.tgz foo/</code>
</pre>
  </li>
  <li>
    <p>
      Confirm that the tarball looks good with these shell commands:
    </p>
<pre>
<code>tar -tf /tmp/foo.tgz
tar -xOf /tmp/foo.tgz</code>
</pre>
  </li>
  <li>
    <p>
      Within Emacs, type <code>C-x C-f /tmp/foo.tgz RET</code> to open
      the tarball.  A list of all entries in the tarball is displayed
      in a Tar buffer.
    </p>
  </li>
  <li>
    <p>
      Type <code>n</code> and <code>p</code> to navigate the Tar
      buffer down and up respectively.
    </p>
  </li>
  <li>
    <p>
      With the cursor on the line
      containing <code>foo/bar/baz/baz.txt</code>,
      type <code>RET</code>.  The content of this entry is now
      displayed in a new buffer.
    </p>
  </li>
  <li>
    <p>
      Now in the buffer that displays the content
      of <code>baz.txt</code>, edit its content.  Say, type <code>C-a
      !</code> to append an exclamation point to this buffer.
    </p>
  </li>
  <li>
    <p>
      Type <code>C-x C-s</code> to save this buffer.  This updates the
      entry of <code>foo/bar/baz/baz.txt</code> within the buffer
      for <code>foo.tgz</code>.  However, the updated tarball is not
      written to the file system yet.
    </p>
  </li>
  <li>
    <p>
      Type <code>C-x b foo.tgz RET</code> to go back to the buffer
      with the tarball entry listing.
    </p>
  </li>
  <li>
    <p>
      Finally, type <code>C-x C-s</code> to save the tarball to the
      file system.
    </p>
  </li>
  <li>
    <p>
      Now repeat step 2.  The updated content
      of <code>foo/bar/baz/baz.txt</code> should now appear in the
      output.
    </p>
  </li>
</ol>
<h2 id="dired-thumbnail-image-browser">Dired: Thumbnail Image Browser</h2>
<p>
  Assuming there is a directory <code>~/foo/</code> that contains
  several image files as well as files of other types, the
  command <code>M-x image-dired RET ~/foo/ RET</code> creates a
  preview buffer of all images in the directory and displays it along
  with a normal dired buffer showing the directory listing.  Both
  buffers are displayed in two separate windows.
</p>
<p>
  When the preview buffer is first launched, all image files found in
  the directory are automatically <em>marked</em>.  This can be seen
  in the Dired buffer.  However the preview buffer does not reflect
  this immediately.  Type <code>m</code> in the preview buffer to
  force it to pick the current list of marked images and highlight
  them.
</p>
<p>
  As a best practice, remember to type <code>m</code> soon after
  launching <code>image-dired</code> so that the marked images are
  accurately displayed in the preview buffer.
</p>
<p>
  Within the preview buffer, the following key sequences are
  supported:
</p>
<ul>
  <li>
    <code>C-f</code>: Move to next image.
  </li>
  <li>
    <code>C-b</code>: Move to the previous image.
  </li>
  <li>
    <code>C-n</code>: Move to next row of images.
  </li>
  <li>
    <code>C-p</code>: Move to previous row of images.
  </li>
  <li>
    <code>RET</code>: Display the original image in a display buffer.
  <li>
    <code>m</code>: Mark an image file.
  </li>
  <li>
    <code>u</code>: Unmark an image file.
  </li>
  <li>
    <code>d</code>: Flag an image file for deletion.
  </li>
  <li>
    <code>t t</code>: Tag marked thumbnails.  If no thumbnails are
    marked, tag the current thumbnail.
  </li>
  <li>
    <code>t r</code>: Remove tag from marked thumbnails.  If no
    thumbnails are marked, remove tag from the current thumbnail.
  </li>
  <li>
    <code>l</code>: Rotate thumbnail left.
  </li>
  <li>
    <code>r</code>: Rotate thumbnail right.
  </li>
</ul>
<h3 id="preview-buffer-quirks">Preview Buffer Quirks</h3>
<p>
  The <code>m</code>, <code>u</code> or <code>d</code> commands in the
  preview buffer are actually meant to mark, unmark or flag the
  corresponding files in the Dired buffer.  The highlighting or
  unhighlighting that occurs in the preview buffer is merely a
  convenience feature.  The preview buffer may not always accurately
  reflect the most recent list of all marked and flagged files.
  Always keep an eye on the Dired buffer to check the most recent
  state of the files.
</p>
<p>
  Especially, if we go back to the Dired buffer and mark, unmark or
  flag files, the preview buffer does not reflect it automatically.
  We need to go to the preview buffer again and perform at least one
  similar operation (<code>m</code>, <code>u</code> or
  <code>d</code>) in the preview buffer for it to be updated again.
  This is why it is important to keep an eye on the Dired buffer to
  get an accurate account of which files are marked or flagged.
</p>
<h3 id="working-on-marked-files">Working on Marked Files</h3>
<p>
  Say we have marked some image files using the key
  sequence <code>m</code> in the preview buffer.  Now we can perform
  various operations on these marked files.  For example, to copy the
  marked files to <code>/tmp/</code> directory, in a Dired buffer,
  type <code>C /tmp/ RET</code>.  To move them instead, type <code>R
  /tmp/</code>.
</p>
<h3 id="deleting-images">Deleting Images</h3>
<p>
  When we flag thumbnails by typing <code>d</code> in the preview
  buffer, the corresponding files are flagged for deletion in the
  Dired buffer.  The first column of the flagged file entries contain
  the letter <code>D</code> in the Dired buffer.  Type <code>x</code>
  in the Dired buffer to permanently delete (expunge) the flagged
  files.
</p>
<h3 id="tagging-and-untagging">Tagging and Untagging</h3>
<p>
  If there are marked images, then the tagging and untagging commands
  executed in the preview buffer work on those marked images.
  Otherwise, they work on image corresponding to the current
  thumbnail.  We will refer to these images that the tagging or
  untagging commands work on as <em>target</em> images in the next few
  paragraphs..
</p>
<p>
  The key sequence <code>t t trip;oxford;uk RET</code> tags the target
  images with the tags <code>trip</code>, <code>oxford</code>
  and <code>uk</code>.  The tags must be separated by semicolon as
  shown in the preceding example.  The tags are saved in a path set in
  the <code>image-dired-db-file</code> variable.  Type <code>C-h v
  image-dired-db-file</code> to read this path.  Typically, it is
  something like <code>~/.emacs.d/image-dired/.image-dired_db</code>.
  We will call this the DB file.  This file may be manually inspected
  to see how this command and the next command affect the tags for
  each thumbnail.  Alternatively, type <code>C-t e</code> in a Dired
  buffer to view and edit the tags of the target files.
</p>
<p>
  The key sequence <code>t r trip RET</code> removes the
  tag <code>trip</code> from the target images.  By virtue of how this
  functionality is implemented, a key sequence like <code>t r
  t.*d</code> removes the tags <code>trip;oxford</code>
  and <code>trip;salford</code> (if present) from the DB file but it
  does not remove a tag like <code>trip;cambridge</code> (if present).
</p>
<h3 id="using-tags">Using Tags</h3>
<p>
  Tagging thumbnails could be useful if we want to later mark files by
  tags.  In a Dired buffer, the key sequence <code>C-t f t.*d</code>
  will mark all files whose thumbnails have tags (as they appear in
  the tags file) matching the regular expression <code>t.*d</code>.
  For example, images that have with tags <code>trip;oxford;uk</code>
  as well as <code>trip;london;uk</code> will be marked but images
  with tags <code>trip;bath;uk</code>
  and <code>trip;liverpool;uk</code> will not be marked.
</p>
<h3 id="display-buffer">Display Buffer</h3>
<p>
  When we type <code>RET</code> in the preview buffer, the original
  image is displayed in a display buffer.  The following key sequences
  are supported in the display buffer:
</p>
<ul>
  <li>
    <code>s</code>: Resize image to fit window.
  </li>
  <li>
    <code>f</code>: Display current image in full size.
  </li>
  <li>
    <code>q</code>: Quit window.
  </li>
</ul>
<p>
  The book makes a note that when we open an image file directly from
  a Dired buffer, the image is opened in <code>image-mode</code> which
  is more powerful than the display buffer we get when we open an
  image from the thumbnail preview window.
</p>
<h2 id="docview">DocView</h2>
<p>
  When a PDF or another document of a supported format is opened in
  Emacs, they are converted to images on the fly and displayed in
  Emacs.  In this section, we will discuss working with PDFs only.
  The converted images are cached at the directory set in
  the <code>doc-view-cache-directory</code> variable.
</p>
<p>
  Type <code>C-h v auto-mode-alist RET</code> and search
  for <code>doc-view</code> in the help buffer to see the list of file
  formats that Emacs tries to open in DocView.
</p>
<p>
  Ghostscript needs to be installed so that DocView can convert the
  PDF into images.  Further, for some commands where we perform
  text-based operations on the PDF, we need the <code>pdftotext</code>
  command so that DocView can extract text from the PDF.
  Type <code>C-h v doc-view-ghostscript-program RET</code>
  and <code>C-h v doc-view-pdftotext-program RET</code> to see the
  external programs that DocView depends on.  These programs can be
  installed with the following command on a Debian or Debian-based
  Linux distribution:
</p>
<pre><code>apt-get install ghostscript poppler-utils</code></pre>
<p>
  On a macOS system, run the following command instead:
</p>
<pre><code>brew install ghostscript poppler</code></pre>
<p>
  The following list presents some of the key bindings supported by
  DocView:
</p>
<ul>
  <li>
    <code>n</code>: Go to next page.
  </li>
  <li>
    <code>p</code>: Go to previous page.
  </li>
  <li>
    <code>C-x ]</code>: Same as <code>n</code>.
  </li>
  <li>
    <code>C-x [</code>: Same as <code>p</code>.
  </li>
  <li>
    <code>SPC</code>: Scroll up if possible or go to next page.
  </li>
  <li>
    <code>DEL</code>: Scroll down if possible or go to the previous page.
  </li>
  <li>
    <code>S-SPC</code>: Same as above.
  </li>
  <li>
    <code>M-&lt;</code>: View the first page.
  </li>
  <li>
    <code>M-&gt;</code>: View the last page.
  </li>
  <li>
    <code>+</code>: Enlarge the document.
  </li>
  <li>
    <code>-</code>: Shrink the document.
  </li>
  <li>
    <code>0</code>: Reset the document size to the initial one.
  </li>
  <li>
    <code>W</code>: Fit the image width to the window width.
  </li>
  <li>
    <code>H</code>: Fit the image height to the window height.
  </li>
  <li>
    <code>P</code>: Fit the image to the window such that neither the
    document width nor the document height exceed the window width or
    height respectively.
  </li>
  <li>
    <code>F</code>: Resize the window so it just fits the page.  When
    there is only window in the frame, the window cannot be resized
    independently of the frame, so the frame is resized instead.
  </li>
  <li>
    <code>M-x doc-view-presentation RET</code>: Display document in
    presentation mode, i.e. as a full screen slide show.
  </li>
</ul>
<p>
  Although not mentioned in the book, here are some commands that show
  how to perform text-based operations on the PDF.  These commands
  need <code>pdftotext</code> to be installed.
</p>
<ul>
  <li>
    <code>C-s ^f..\&gt; RET</code>: Initiate a new search for lines
    that begin with a three-lettered word beginning with the
    letter <code>f</code>.  The cursor does not move to the first
    match automatically.  To make the cursor move to the first match,
    type <code>C-s</code>.  This is also explained in the next point.
  </li>
  <li>
    <code>C-s</code>: When a search has been initiated, jump to the
    next match for the last search that was initiated.
  </li>
  <li>
    <code>C-u C-s ^b..\&gt; RET</code>: Initiate a new search.  This
    is useful when a search was already initiated and we want to
    abandon that search and start another new search.
  </li>
  <li>
    <code>C-r</code>: Similar to <code>C-s</code> but works in reverse
    direction.  All three commands mentioned above work
    with <code>C-r</code> too.
  </li>
  <li>
    <code>C-t</code>: Show tooltip for the current location.
    Normally, this shows a tooltip like "Page 100 of 314" to describe
    the current page.  When a search is in progress, the tooltip
    includes all the matches from the current page too.
  </li>
  <li>
    <code>C-c C-t</code>: Show the current document's content as text.
    Then type the key sequence <code>C-c C-c</code> to switch to
    editing the document and <code>C-c C-c</code> again to switch to
    viewing the document.  The key sequence <code>C-c C-c</code> is
    elaborated a little more in the next point.
  </li>
  <li>
    <code>C-c C-c</code>: Toggle between editing or viewing the
    document.  In case of PDF, switching to editing the document may
    not be very helpful because the binary code of the document is
    opened for editing in this mode which is quite non-trivial to edit
    directly.
  </li>
</ul>
<h3 id="docview-resolution">DocView Resolution</h3>
<p>
  If the text in the document looks pixelated in Emacs, set
  the <code>doc-view-resolution</code> variable to 300 as follows:
</p>
<pre><code>(setq doc-view-resolution 300)</code></pre>
<p>
  This sets the dots per inch resolution used to render the documents
  to 300.  This offers a good trade-off between high quality rendering
  and fast rendering.  After setting this variable, type the following
  key sequences:
</p>
<ul>
  <li>
    <code>M-x doc-view-clear-cache RET</code> to delete the cache
    directory.
  </li>
  <li>
    <code>C-x k</code> to kill the existing DocView buffer (if any).
  </li>
  <li>
    <code>C-x C-f document.pdf RET</code> to open the document
    (say <code>document.pdf</code>) again!
  </li>
</ul>
<p>
  Clearing the cache directory and reopening the document in this
  manner regenerates the images from the documents with the updated
  resolution.
</p>
<h2 id="tramp">TRAMP</h2>
<p>
  TRAMP stands for Transparent Remote Access, Multiple Protocol.  The
  general syntax of paths supported by TRAMP is:
</p>
<pre><code>/method:[user@][hostname[#port]]:[path]</code></pre>
<p>
  Here
  are some complete key sequences that demonstrate various ways to
  open a remote file using TRAMP:
</p>
<ul>
  <li>
    <code>C-x C-f /ssh:alice@box:~/foo.txt RET</code>: Edit file in a
    remote host via SSH.
  </li>
  <li>
    <code>C-x C-f /ssh:susam@box#22:~/foo.txt RET</code>: Same as
    above.  However the port is explicitly specified this time.
  </li>
  <li>
    <code>C-x C-f /scp:alice@box:~/foo.txt RET</code>: Edit file in a
    remote host via SCP.
  </li>
  <li>
    <code>C-x C-f /ssh:box:~/foo.txt RET</code>: Edit file in a
    remote host via SSH after logging into it with the username of the
    current user in the current shell.
  </li>
  <li>
    <code>C-x C-f /ssh:alice@:~/foo.txt RET</code>: Edit file in
    localhost via SSH after logging into it as a specific user.
  </li>
  <li>
    <code>C-x C-f /ssh::~/foo.txt RET</code>: Edit file in localhost
    via SSH after logging into it with the username of the current
    user in current shell.
  </li>
  <li>
    <code>C-x C-f /sudo::/etc/hosts</code>: Edit file as superuser.
  </li>
  <li>
    <code>C-x c-f /sudo:alice@:~/foo.txt RET</code>: Edit file as
    a specific user.
  </li>
  <li>
    <code>C-x C-f /sudoedit::/etc/hosts</code>: Edit file as superuser
    but do not keep an open session running in the background for
    security reasons.  This method has worse performance than
    the <code>sudo</code> method.
  </li>
  <li>
    <code>C-x C-f /su::/etc/hosts</code>: Edit file as
    the <code>root</code> user.
  </li>
  <li>
    <code>/su:alice@:~/foo.txt</code>: Edit file as a specific user.
  </li>
  <li>
    <code>/su:alice@localhost:~/foo.txt</code>: Same as above.
  </li>
  <li>
    <code>C-x C-f /sudo:: RET</code>: Browse the <code>root</code>
    user's home directory as superuser.
  </li>
  <li>
    <code>C-x C-f /su:: RET</code>: Browse the <code>root</code>
    user's home directory with Dired.
  </li>
  <li>
    <code>C-x C-f /-:: RET</code>:
    Use <code>tramp-default-method</code> (<code>scp</code> by
    default) to connect to <code>tramp-default-host</code>
    (current <code>hostname</code> by default).  With the default
    values of these variables, this leads to connecting to the local
    system as the current user via SCP and browsing the current user's
    home directory in Dired.
  </li>
</ul>
<p>
  This chapter recommends looking up the info manual
  page <code>(tramp) Internal methods</code> but this is very likely
  an error.  For example, evaluating <code>(info "(tramp)Internal
  methods")</code> leads to the following error:
</p>
<pre><code>user-error: No such node or anchor: Internal methods</code></pre>
<p>
  Instead evaluate <code>(info "(tramp)Inline methods")</code> to
  reach the correct node that describes the various connection
  methods.
</p>
<h3 id="default-directory">Default Directory</h3>
<p>
  The variable <code>default-directory</code> is buffer local.
  Typically, this is automatically set to the directory where Emacs
  was launched or to the directory of the currently visited file.
  Commands like <code>C-x C-f</code> defaults to looking up files in
  this directory.
</p>
<p>
  While editing a remote file via TRAMP, the value for this variable
  may look something like <code>/ssh:alice@box:/home/alice/</code>.
  The <code>@</code> character is displayed in the mode line while
  editng a remote file.
</p>
<p>
  The chapter presents the following examples of commands that work
  seamlessly on a remote machine:
</p>
<ul>
  <li>
    <code>C-x d</code>: Manage remote files and directories.  We can
    even copy files (using the key sequence <code>C</code>) between
    remote and local dired sessions.
  </li>
  <li>
    <code>M-x compile RET RET</code>: Run <code>make -k</code> (the
    default) or an arbitrary command remotely.  The result is shown in
    the <code>*compilation*</code> buffer.
  </li>
  <li>
    <code>M-x rgrep RET f.. RET *.txt RET RET</code>:
    Use <code>find</code> and <code>grep</code> together to search for
    the pattern <code>f..</code> in files matching the
    pattern <code>*.txt</code> in the current remote directory.
  </li>
  <li>
    <code>M-x shell RET</code>: Open shell on the remote system in the
    current remote directory.
  </li>
  <li>
    <code>M-x eshell RET</code>: Open Eshell on the remote system in
    the current remote directory.
  </li>
</ul>
<p>
  With Eshell we can go directly into remote directories seamlessly.
  The following Eshell session illustrates this:
</p>
<pre>
<samp>Welcome to the Emacs shell

~ $ <kbd>uname</kbd>
Darwin
~ $ <kbd>cd /ssh:alice@box:~/foo/</kbd>
/ssh:alice@box:/home/alice/foo $ <kbd>hostname</kbd>
debian
/ssh:alice@box:/home/alice/foo $</samp>
</pre>
<h3 id="multi-hops">Multi-Hops</h3>
<p>
  Here are some commands that illustrate how multi-hops work:
</p>
<ul>
  <li>
    <code>C-x C-f /ssh:alice@box|ssh:bob@localhost:~/foo.txt
    RET</code>: First log in as <code>alice</code>
    into <code>box</code> and then from there log in
    as <code>bob</code> into the same system.
  </li>
  <li>
    <code>C-x C-f /ssh:alice@box|sudo:box:/etc/hosts RET</code>: First
    log in as <code>alice</code> into <code>box</code> and then edit
    file as superuser.
  </li>
  <li>
    <code>C-x C-f /ssh:alice@box|sudo::/etc/hosts RET</code>: Same as
    above.
  </li>
  <li>
    <code>C-x C-f /ssh:alice@box|sudo:bob@box:~/bar.txt RET</code>:
    First log in as <code>alice</code> into <code>box</code> and then
    use <code>sudo</code> to edit file as <code>bob</code> in the
    latter user's home directory.
  </li>
  <li>
    <code>C-x C-f /ssh:alice@box|su::/etc/hosts RET</code>: First log
    in as <code>alice</code> into <code>box</code> and then edit file
    as <code>root</code>.
  </li>
  <li>
    <code>C-x C-f /ssh:alice@box|su:bob@:~/bar.txt RET</code>: First log
    in as <code>alice</code> into <code>box</code> and then edit file
    as <code>bob</code>.
  </li>
  <li>
    <code>C-x C-f /ssh:alice@box|su:bob@box:~/bar.txt RET</code>: Same
    as above.
  </li>
  <li>
    <code>C-x C-f /ssh:alice@box1|ssh:bob@box2|ssh:carol@box3:~/foo.txt</code>:
    An example of two hops.
  </li>
</ul>
<p>
  Bookmarks with key sequences like <code>C-x r m</code>
  (<code>bookmark-set</code>), <code>C-x r l</code>
  (<code>bookmark-bmenu-list</code>) and <code>C-x r b</code>
  (<code>bookmark-jump</code>) work seamlessly for remote files
  (including multi-hops).
</p>
<p>
  Eshell works seamlessy too across multi-hops.  Here is an Eshell
  session that illustrates it:
</p>
<pre>
<samp>~ $ <kbd>uname</kbd>
Darwin
~ $ <kbd>cd '/ssh:alice@box1|ssh:bob@box2|ssh:carol@box3:/home/carol/foo/bar/'</kbd>
/ssh:alice@box1|ssh:bob@box2|ssh:carol@box3:/home/carol/foo/bar $ <kbd>uname</kbd>
Linux
/ssh:alice@box1|ssh:bob@box2|ssh:carol@box3:/home/carol/foo/bar $</samp>
</pre>
<h2 id="eww">EWW: Emacs Web Wowser</h2>
<p>
  The following commands are useful to get started with EWW.
</p>
<ul>
  <li>
    <code>M-x eww RET hello RET</code>: Search for the word "hello"
    with DuckDuckGo.  If the buffer <code>*eww*</code> already exists,
    then reuse that buffer, otherwise create such a buffer.  The
    search engine can be customised by setting the
    variable <code>eww-search-prefix</code> (it
    is <code>"https://duckduckgo.com/html/?q="</code> by default).
  </li>
  <li>
    <code>C-u M-x eww RET hello RET</code>: Like previous command
    except that it creates a new EWW buffer.
  </li>
  <li>
    <code>M-x eww RET example.net RET</code>: Visit the
    URL <a href="http://example.net/">http://example.net</a>.  Reuses
    the <code>*eww*</code> buffer if it exists.
  </li>
  <li>
    <code>M-x eww RET http://example.net/ RET</code>: Same as above.
  </li>
  <li>
    <code>C-u M-x eww RET example.net RET</code>: Like before but
    creates a new EWW buffer.
  </li>
</ul>
<p>
  In the EWW buffer, the following navigation keys work:
</p>
<ul>
  <li>
    <code>TAB</code>: Skip to the next link.
  </li>
  <li>
    <code>S-TAB</code> or <code>C-M-i</code>: Skip to the previous link.
  </li>
  <li>
    <code>RET</code>: Browse the URL under point.
  </li>
  <li>
    <code>C-u RET</code>: Browse the URL under point using an external
    browser.  This is especially useful when we know that the URL we
    want to open does not render well in EWW.
  </li>
  <li>
    <code>&amp;</code>: Open the current page in an external browser.
    Note that unlike the previous command, this command opens
    the <em>current</em> page.  The previous command opens the URL
    under point instead.
  </li>
  <li>
    <code>q</code>: Quit EWW.
  </li>
  <li>
    <code>l</code>: Go to the previously displayed page.
  </li>
  <li>
    <code>r</code>: Go to the next displayed page.
  </li>
  <li>
    <code>b</code>: Bookmark the current page.
  </li>
  <li>
    <code>B</code>: Show bookmarks.
  </li>
  <li>
    <code>H</code>: Show history of the current EWW buffer.  The most
    recently visited URLs are displayed on top and the oldest ones are
    shown at the bottom.  The current URL is not displayed in the
    history.  Only the older URLs are shown in the history.
  </li>
  <li>
    <code>R</code>: View the main "readable" parts of the current
    page.  This command uses heuristics to find the parts of the web
    page that contains the main content and omits the non-content part
    like navigation menus etc.
  </li>
  <li>
    <code>M-s M-w</code>: Search the web for the text in the region.
    If there is no region, then prompt for a search string.
  </li>
  <li>
    <code>M-RET</code>: Open link in a new EWW buffer.
  </li>
  <li>
    <code>s</code>: Prompt for an EWW buffer to display and switch to
    the selected buffer.  This is similar to changing to tabs in a
    desktop web browser.
  </li>
  <li>
    <code>w</code>: If the point is on a URL or just after a URL, then
    copy that URL to the kill ring.  If the point is at any other
    place, copy the URL of the current page.
  </li>
</ul>
<p>
  Further, EWW supports a few semantic browsing methods.  The
  pertaining commands are presented below.  However note that whether
  these commands would work on a page or not depends on whether the
  page provides the relevant navigation aids required by these
  commands.  Here are the key sequences for such commands:
</p>
<ul>
  <li>
    <code>p</code>: Go to the page marked <em>previous</em>.  A page
    is marked <em>previous</em> if there is
    a <code>&lt;link&gt;</code> tag or an <code>&lt;a&gt;</code> tag
    for it with the attribute <code>rel="prev"</code> (a standard
    value for the attribute) or <code>rel="previous"</code>
    (non-standard value supported by EWW).
  </li>
  <li>
    <code>n</code>: Go to the page marked <em>next</em>.  A page is
    marked <em>next</em> if there is a <code>&lt;link&gt;</code> tag
    or an <code>&lt;a&gt;</code> tag for it with the
    attribute <code>rel="next"</code>.
  </li>
  <li>
    <code>u</code>: Go to the page marked <em>up</em>.  A page is
    marked <em>up</em> if there is a <code>&lt;link&gt;</code>
    or an <code>&lt;a&gt;</code> tag for it with the
    attribute <code>rel="up"</code>.
  </li>
  <li>
    <code>t</code>: Go to the page marked <em>top</em>.  A page is
    marked <em>top</em> if there is a <code>&lt;link&gt;</code> tag or
    an <code>&lt;a&gt;</code> tag for it with the
    attribute <code>rel="start"</code> or <code>rel="home"</code>
    or <code>rel="contents"</code>.
  </li>
</ul>
<h2 id="invoking-external-browser">Invoking External Browser</h2>
<p>
  If we would rather open a URL using our desktop web browser, then we
  can use the <code>browse-url</code> command like this: <code>M-x
  browse-url RET http://example.net/ RET</code>.
</p>
<p>
  This command very conveniently picks up the word or domain name at
  the point or just before the point and uses that as the default
  value for the URL input.  Therefore if the cursor is already on a
  URL, then we can simply type <code>M-x browse-url RET RET</code> to
  visit it.
</p>
<h2 id="dired">Dired</h2>
<h3 id="dired-getting-started">Dired: Getting Started</h3>
<p>
  There are several ways to start Dired.  Some examples are presented
  below:
</p>
<ul>
  <li>
    <code>C-x C-f ~/foo/bar/ C-d</code>: If IDO or FIDO mode is
    enabled, then this key sequence automatically opens Dired in the
    given directory path.  Essentially, while using <code>C-x
    C-f</code> with IDO/FIDO mode, we can type <code>C-d</code>
    anytime and Dired is opened in the path entered so far.
  </li>
  <li>
    <code>M-x dired RET ~/foo/bar/ RET</code>: Opens Dired in the
    given directory path.
  </li>
  <li>
    <code>M-x dired RET RET</code>: In the previous command, the
    default input is the path of the current directory
    (<code>default-directory</code>), so this key sequence
    conveniently opens Dired in the current directory.
  </li>
  <li>
    <code>C-x d</code>: Same as above.
  </li>
  <li>
    <code>C-x 4 d</code>: Like before but open Dired in another
    window.
  </li>
</ul>
<h3 id="dired-navigation">Dired: Navigation</h3>
<p>
  The following keys work in a Dired buffer:
</p>
<ul>
  <li>
    <code>RET</code>: Visit the file or directory on the current line.
  </li>
  <li>
    <code>^</code>: Go up by one directory.  If the parent directory
    is found in an existing buffer, then switch to that buffer.
    Otherwise create a new buffer to show the parent directory in
    Dired.
  </li>
  <li>
    <code>q</code>: Quit Dired window.  The buffer remains intact,
    i.e. the buffer is only buried, not killed.
  </li>
  <li>
    <code>C-u q</code>: Quit Dired window and kill the buffer.
  </li>
  <li>
    <code>p</code> or <code>C-p</code>: Move to the previous line and
    position the point on the filename.
  </li>
  <li>
    <code>n</code> or <code>C-n</code>: Move to the next line and
    position the point on the filename.
  </li>
</ul>
<p>
  Note that when we go from one Dired buffer to another (say, by
  typing <code>RET</code> to enter a subdirectory from a parent
  directory), then typing <code>q</code> or <code>C-u q</code> buries
  or kills (respectively) the current buffer and takes us back to the
  last Dired buffer.
</p>
<h3 id="dired-marking-and-unmarking">Dired: Marking and Unmarking</h3>
<p>
  The following list describes marking and unmarking commands of
  Dired:
</p>
<ul>
  <li>
    <code>m</code>: Mark the file or directory at point.  If the
    region is active, mark all files or directories in the region.
    Note that at least one character of the filename or directory name
    must lie within the region for a file to be marked.
  </li>
  <li>
    <code>u</code>: Unmark the file or directory at point.  If the
    region is active, unmark all files or directories in the region.
    Note that this also removes the flag for deletion (introduced
    later in this list).
  </li>
  <li>
    <code>U</code>: Unmark everything.  Note that this also removes
    flags for deletion.
  </li>
  <li>
    <code>d</code>: Flag the file or directory for deletion.  If the
    region is active, flag all files or directories in the region for
    deletion.
  </li>
</ul>
<p>
  The following key sequences describe the effects of prefix arguments
  with marking, unmarking and flagging commands:
</p>
<ul>
  <li>
    <code>C-5 m</code>: Mark 5 files from the current line to 4 more
    lines below.
  </li>
  <li>
    <code>C-5 u</code>: Unmark 5 files from the current line for
    deletion..
  </li>
  <li>
    <code>C-5 d</code>: Flag 5 files from the current line for deletion.
  </li>
  <li>
    <code>C-- C-1 m</code>: Mark the file on the previous line.
  </li>
  <li>
    <code>C-- C-1 u</code>: Unmark the file on the previous line.
  </li>
  <li>
    <code>C-- C-1 d</code>: Flag the file on the previous line for deletion.
  </li>
  <li>
    <code>C-- C-5 m</code>: Mark files in the 5 previous lines.
  </li>
  <li>
    <code>C-- C-5 u</code>: Unmark files in the 5 previous lines.
  </li>
  <li>
    <code>C-- C-5 d</code>: Flag files in the 5 previous lines for
    deletion.
  </li>
</ul>
<p>
  Additionally, the chapter mentions the following commands in a
  separate table but on Emacs 28.2, they seem to have the same effect
  as one of the commands discussed earlier:
</p>
<ul>
  <li>
    <code>* m</code>: Behaves the same as <code>m</code> and marks
    files.
  </li>
  <li>
    <code>* u</code>: Behaves the same as <code>u</code> and unmarks
    files.
  </li>
</ul>
<p>
  However the following commands (also introduced briefly in the same
  table but illustrated with complete key sequences below) provide
  additional marking and unmarking facilities:
</p>
<ul>
  <li>
    <code>* % f.. RET</code>: Mark files with names that match the
    regular expression <code>f..</code>.  If the region is active,
    then only the files in the region that match the pattern are
    marked.  The directories <code>.</code> and <code>..</code> are
    never marked.
  </li>
  <li>
    <code>% m f.. RET</code>: Same as above.
  </li>
  <li>
    <code>C-u * % f.. RET</code>: Unmark files with names that match
    the regular expression <code>f..</code>.  If the region is active,
    then only the files in the region that match the pattern are
    unmarked.  The directories <code>.</code> and <code>..</code> are
    never unmarked.
  </li>
  <li>
    <code>C-u % m f.. RET</code>: Same as above.
  </li>
  <li>
    <code>t</code> or <code>* t</code>: Toggle marks.  The marked
    files become unmarked and vice versa.  If the region is active,
    toggle the marks of only the files in the region.  The
    directories <code>.</code> and <code>..</code> are never toggled.
    Flagged files are not toggled.
  </li>
  <li>
    <code>* c * D</code>: Change all files marked with <code>*</code>
    to be now marked with <code>D</code> (i.e. flagged for deletion).
    Note that unlike the other commands, this command ignores the
    active region.  It performs the change in the whole buffer.
  </li>
  <li>
    <code>* c D SPC</code>: Change all files marked
    with <code>D</code> to be now unmarked.
  </li>
</ul>
<p>
  The chapter also mentions a key sequence <code>* .</code> to mark
  files by extension but this requires <code>dired-x</code>, so this
  is discussed in a later section of this page.
</p>
<h3 id="dired-operations">Dired: Operations</h3>
<p>
  This section explains some operations we can perform in Dired.  If
  there are one or more items marked in the Dired buffer, then the
  operations work on the marked items.  Otherwise, the operations work
  on the item under the cursor.
</p>
<ul>
  <li>
    <code>C</code>: Copy marked files or copy the current file.  If
    one file is being copied, this command prompts for the target file
    path.  If multiple files are being copied, this command prompts
    for the target directory path.
  </li>
  <li>
    <code>R</code>: Rename marked files or the current file.  If one
    file is being renamed, this command prompts for the target file
    path.  If multiple file are being renamed, this command prompts
    for the target directory path.
  </li>
  <li>
    <code>O</code>: Change owner of the marked files or the current
    file.  A complete key sequence may look like <code>O root
    RET</code>.
  </li>
  <li>
    <code>G</code>: Change group of the marked files or the current
    file.  A complete sequence may look like <code>G wheel RET</code>.
  </li>
  <li>
    <code>M</code>: Change the mode of the marked files or the current
    file.  A complete key sequence may look like <code>M u+x
    RET</code> or <code>M 600 RET</code>.  Both symbolic modes
    like <code>u+x</code> and numeric modes like <code>600</code> are
    supported.
  </li>
  <li>
    <code>D</code>: Delete marked files, i.e. the files that are
    marked with <code>*</code> on the leftmost column of the Dired
    buffer.
  </li>
  <li>
    <code>x</code>: Delete the files flagged for deletion, i.e. the
    files that are marked with <code>D</code> on the leftmost column
    of the Dired buffer.
  </li>
  <li>
    <code>c</code>: Compress marked files or current file into an
    archive.  The archive file name is prompted.  The format of the
    archive is automatically deduced from the extension of the file
    name entered at the prompt.  A complete key sequence may look
    like <code>c foo.tar.gz RET</code> or <code>c foo.zip RET</code>.
  </li>
</ul>
<p>
  Note the difference between <code>D</code> and <code>x</code>.  The
  key <code>D</code> deletes marked files but the key <code>x</code>
  deletes flagged files.  Therefore there are two ways of deleting
  files:
</p>
<ul>
  <li>
    Mark files with <code>m</code> and delete them with <code>D</code>.
  </li>
  <li>
    Flag files with <code>d</code> and delete them with <code>x</code>.
  </li>
</ul>
<p>
  I normally prefer the second way of deleting files.  Since deleting
  file is a destructive operation which is possibly risky, I like to
  flag them first with <code>d</code> before deleting them
  with <code>x</code>.  In other words, I flag files for deletions and
  mark files for everything else.  Since I do not use
  the <code>D</code> key, I can be confident that my marked files are
  always safe and there is no risk of inadvertently deleting them.
</p>
<h3 id="dired-copying-or-renaming-between-buffers">Dired: Copying or Renaming Between Buffers</h3>
<p>
  The following steps explain how we can copy or move files from one
  Dired buffer to another.  First we will see the default behaviour
  and then we will customise Dired to copy or move files to a
  particular Dired directory.
</p>
<ol>
  <li>
    Type <code>C-x d /usr/ RET</code>.
  </li>
  <li>
    Type <code>C-x 2</code>.
  </li>
  <li>
    Type <code>C-x d /tmp/ RET</code>.
  </li>
  <li>
    Type <code>C-x 2</code> agian.
  </li>
  <li>
    Type <code>C-x d /etc/ RET</code>.
  </li>
  <li>
    Move the cursor on some file in <code>/etc/</code> and then
    type <code>C</code> or <code>R</code> and we will see that the
    default directory to copy/move the file to is <code>/etc/</code>.
  </li>
  <li>
    Now type <code>(setq dired-dwim-target t)</code>.
  </li>
  <li>
    Now type <code>C</code> or <code>R</code> again while the cursor
    is on some file in <code>/etc/</code>.  We will see that the
    default directory to copy/move the file to is <code>/tmp/</code>
    now.  Since <code>dired-dwim-target</code> is set to non-nil,
    Dired picks the directory from the next window with a Dired buffer
    and uses that as the target buffer.
  </li>
</ol>
<h3 id="dired-more-keys">Dired: More Keys</h3>
<p>
  Here are some examples of Dired keys that do not act on marked files
  but does other interesting work:
</p>
<ul>
  <li>
    <code>g</code>: Refresh the Dired buffer.
  </li>
  <li>
    <code>+</code>: Create directory.  A complete key sequence may
    look like <code>+ bar RET</code>.
  </li>
  <li>
    <code>s</code>: Toggle sorting by date.  By default, the items in
    the Dired buffer are sorted by file/directory names.
  </li>
  <li>
    <code>&lt;</code>: Jump to the next directory.
  </li>
  <li>
    <code>&gt;</code>: Jump to the previous directory.
  </li>
  <li>
    <code>j</code>: Jump to a file by name.  A complete sequence may
    look like <code>j hosts RET</code>.  Note that this only moves the
    cursor to the line in Dired buffer with the provided filename.  It
    does not visit the file.
  </li>
  <li>
    <code>M-s a C-s</code>: Perform multi-file incremental search
    through all marked files or the current file.  Marked directories
    are ignored.  Action region is also ignored.  It performs the
    search across all marked files.  A complete key sequence may look
    like <code>M-s a C-s foo</code> and then repeat <code>C-s</code>
    over and over again to jump through all the matches.  When the
    search reaches the end of one file, the next <code>C-s</code>
    automatically jumps to the match in the next file.
  </li>
  <li>
    <code>Q</code>: Perform multi-file regex-based search-and-replace
    operation through all marked files or the current file.  For any
    marked directories, the search-and-replace operation is performed
    in all its files recursively.  The active region is ignored.  A
    complete key sequence may look like <code>Q f.. RET \&amp;\&amp;
    RET</code> which searches for strings matching the
    pattern <code>f..</code>  and duplicates that string.  The key
    sequences supported by <code>C-M-%</code>
    (<code>query-replace-regexp</code>)
    like <code>y</code>, <code>n</code>, etc. work here.  See
    section <a href="ch05.html#search-and-replace">Search and
    Replace</a> for an account of the supported key sequences.  The
    search results are also displayed in a
    separate <code>*xref*</code>
  </li>
  <li>
    <code>A</code>: Find matches for a regular expression pattern in
    all marked files or the current file.  For any marked directories,
    all its files are searched recursively.  The active region is
    ignored.  A complete key sequence may look like <code>A
    f.. RET</code>.  Note that this does not perform incremental
    search.  Instead the search results are displayed in
    <code>*xref*</code> buffer.
  </li>
  <li>
    <code>!</code>: Run a shell command on each marked file or
    directory (or the current file or directory if nothing is marked).
    The command is executed synchronously.  The active region is
    ignored or the current file or directory.  The command works on
    all marked files and directories.  The output is displayed in a
    separate buffer.  If <code>*</code> is present in the command,
    then each <code>*</code> is replaced with the entire file list and
    the command runs only once (not multiple times, once for each
    file).  If <code>?</code> is present in the command, then the
    command runs multiple times, once for each marked file, with
    each <code>?</code> replaced with the name of the file being
    operated on.  It is an error to specify both <code>*</code>
    and <code>?</code>.  If neither is present, then the command runs
    multiple times, once for each marked file.
  </li>
  <li>
    <code>&amp;</code>: Like the previous command but runs the command
    asynchronously.
  </li>
</ul>
<p>
  To understand the usefulness of <code>g</code>, while Dired is open
  create a new file in the current directory with, say, <code>C-x C-f
  foo.txt RET</code> and save it with <code>C-x s</code>.  Then kill
  the buffer for the file with <code>C-x k</code> and return to the
  Dired buffer.  The Dired buffer does not show the new
  file <code>foo.txt</code>.  Now type <code>g</code> to refresh the
  Dired buffer.  As soon as <code>g</code> is typed, the buffer gets
  updated to display the new file.
</p>
<p>
  To understand the difference between <code>!</code> and
  <code>&amp;</code> mark five files and then type the key
  sequence <code>! sleep 1; echo</code>.  Emacs blocks (i.e. does not
  react to our keystrokes) for 5 seconds while it runs the given
  command for each file.  When the <code>echo</code> output for all
  files is obtained after 5 seconds, the output appears and Emacs
  unblocks again.  Now type <code>&amp; sleep 1; echo</code>.  Now
  Emacs remains unblocked while the output of each <code>echo</code>
  command appears at one second intervals in the output buffer.
</p>
<h3 id="dired-x">Dired-X</h3>
<p>
  Dired-X provides extra Dired functionality.  It is not enabled by
  default.  To enable it, add the following line to the Emacs
  initialisation file:
</p>
<pre><code>(require 'dired-x)</code></pre>
<p>
  The following key sequences are supported by Dired-X:
</p>
<ul>
  <li>
    <code>F</code>: Visit the marked files or the current file.  When
    multiple files are visited, they are opened in split windows
    distributed as evenly as possible.
  </li>
  <li>
    <code>C-u F</code>: Visit the marked files or the current file but
    open them in background, i.e. do not show them on any window.
  </li>
  <li>
    <code>* .</code>: Mark files with a certain extension.  If the
    region is active, then mark only the files in the region that have
    the given extension.  A complete key sequence may look
    like <code>* . txt</code>.
  </li>
  <li>
    <code>!</code> and <code>&amp;</code>: These commands still work
    the way they were described in the previous section.  However with
    Dired-X enabled, when <code>!</code> or <code>&amp;</code> is
    invoked on a single file (either a single marked file or no marked
    file in which case it operates on the current file), it
    automatically determines the command to execute for the current
    file type and offers that as the default input.
  </li>
</ul>
<h3 id="dired-working-across-directories">Dired: Working Across Directories</h3>
<p>
  The following key sequences offer some support for working across
  multiple directories in the same Dired buffer:
</p>
<ul>
  <li>
    <code>i</code>: While the cursor is on a line for a directory, it
    expands the directory listing for that directory in the same Dired
    buffer.  Now we could use the mark, unmark, etc. commands to
    select files that belong to multiple directories and operate on
    them from the same Dired buffer.
  </li>
  <li>
    <code>$</code>: Collapse or expand the current directory listing.
    If there are multiple directory listings (such as the ones created
    with <code>i</code>), then move to the next directory listing
    after collapsing or expanding the current one.
  </li>
</ul>
<p>
  Using <code>i</code> to insert the directory listing of a
  subdirectory into the current Dired buffer could feel tedious if we
  want to recursively work on multiple directories.  The commands
  (illustrated with complete key sequences below) may be more suitable
  for such operations:
</p>
<ul>
  <li>
    <p>
      <code>M-x find-dired RET RET -name SPC "f*.txt" RET</code>: Find
      all files and directories in the current directory and its
      subdirectories recursively with name matching the
      pattern <code>f*.txt</code> and show the results in the buffer
      named <code>*Find*</code> with Dired mode enabled in it.  Emacs
      runs the following command to get the results:
    </p>
    <pre><code>find . \( -name "f*.txt" \) -ls</code></pre>
  </li>
  <li>
    <p>
      <code>M-x find-name-dired RET RET f*.txt RET</code>: Same as
      above.  Emacs runs the following command to get the results:
    </p>
    <pre><code>find . \( -name f\*.txt \) -l</code></pre>
    <p>
      Further on a system with case-insensitive filenames, Emacs is
      clever enough to use the <code>-iname</code> argument instead
      of <code>-name</code> so that case-insensitive search is
      performed.
    </p>
  </li>
  <li>
    <p>
      <code>M-x find-grep-dired RET RET f.. RET</code>: Find all files
      in the current directory and its subdirectories recursively and
      list the files where lines matching the regular
      expression <code>..</code> is found.  The result is shown in a
      the buffer named <code>*Find</code> with Dired mode enabled in
      it.  Emacs runs the following command to get the results:
    </p>
    <pre><code>find . \( -type f -exec grep -q -e f.. \{\} \; \) -ls</code></pre>
  </li>
  <li>
    <p>
      <code>M-x find-lisp-find-dired RET RET f.. RET</code>: Find all
      files in the current directory and subdirectories recursively
      and list the files with names that match the regular expression
      pattern <code>..</code>.  Note that this is different from
      both <code>find-name-dired</code>
      and <code>find-grep-dired</code>.  The former relies on the
      Unix <code>find</code> command to match filenames using glob
      patterns.  The latter uses both <code>find</code>
      and <code>grep</code> to list files that contain a line with a
      matching regular expression pattern.  However this command lists
      files with names that match a regular expression pattern (not
      glob pattern).  Further this command is implemented purely in
      Elisp and does not have any external dependencies on tools
      like <code>find</code> and <code>grep</code>.
    </p>
  </li>
</ul>
<h2 id="shell-commands">Shell Commands</h2>
<p>
  The following complete key sequences demonstrate how we can invoke
  shell commands from Emacs.
</p>
<ul>
  <li>
    <code>M-! uname RET</code>: Execute shell command and show output.
  </li>
  <li>
    <code>C-u M-! uname RET</code>: Like above but insert the output
    into the buffer wherever the cursor is.  The cursor remains at the
    same place.  The mark is set to the character just after the last
    character of the output.  Therefore, typing <code>C-x C-x</code>
    (<code>exchange-point-and-mark</code>) is a quick way to highlight
    the output just inserted as an active region.
  </li>
  <li>
    <code>M-! ping SPC -c SPC 4 SPC localhost RET</code>: Execute a
    slightly long running shell command that takes about 4 seconds to
    complete.  Emacs blocks while the command is running because the
    command is executed synchronously.
  </li>
  <li>
    <code>C-u M-! ping SPC -c SPC 4 SPC localhost RET</code>: Like
    before but the output is inserted into the buffer.  Again, Emacs
    blocks while the command is executed.  The output appears in the
    buffer only after the command completes execution.
  </li>
  <li>
    <code>M-&amp; ping SPC -c SPC 4 SPC localhost RET</code>:
    Like <code>M-!</code> but execute shell command asynchronously.
    Emacs remains unblocked and the output appears in the output
    buffer as soon as the output is printed by the command.
  </li>
  <li>
    <code>M-| wc RET</code>: Pipe region to shell command and show
    output.
  </li>
  <li>
    <code>C-u M-| wc RET</code>: Pipe region to shell command and
    replace the region with the output.
  </li>
</ul>
<p>
  The book also mentions that <code>C-u M-&amp;</code> is supposed to
  work like <code>C-u M-!</code> but asynchronously but I did not find
  this to be true.  For example, <code>C-u M-&amp; uname RET</code>
  led to the following error <code>Wrong type argument: stringp,
  (4)</code>.  This may be a bug in Emacs 28.2.
</p>
<h2 id="compiling-in-emacs">Compiling in Emacs</h2>
<p>
  The following complete key sequences demonstrate this feature:
</p>
<ul>
  <li>
    <code>M-x compile RET</code>: Runs <code>make -f</code> by
    default.  The default command is offered as a minibuffer input
    before we type <code>RET</code>.  Therefore we can edit the
    command to any arbitrary command before typing <code>RET</code>.
  </li>
  <li>
    <code>M-x recompile RET</code>: Runs the last compile command
    again.
  </li>
  <li>
    <code>C-x p c</code>: Compile in the current project.  See
    section <a href="#project-management">Project Management</a> for
    more details.
  </li>
</ul>
<p>
  The compile commands display the output in
  the <code>*compilation*</code> buffer where the following key
  sequences work:
</p>
<ul>
  <li>
    <code>M-g M-n</code>: Jump to the next error.  The cursor jumps to
    the next error line in the <code>*compilation*</code> and the
    source of the matching error line is opened in a separated window.
  </li>
  <li>
    <code>M-g M-p</code>: Jump to the previous error.
  </li>
  <li>
    <code>g</code>: Recompile, i.e. run the last compile command
    again.
  </li>
</ul>
<h2 id="shells-in-emacs">Shells in Emacs</h2>
<h3 id="m-x-shell">M-x shell</h3>
<p>
  The key sequence <code>M-x shell RET</code> starts a shell with
  input/output done via a buffer.  Some important points to keep in
  mind while using this:
</p>
<ul>
  <li>
    The TAB-completion mechanism of the underlying shell (e.g. Bash,
    Zsh, etc.) does not work.  In fact, <code>TAB</code> invokes
    Emacs's own completion mechanism.
  </li>
  <li>
    Programs like <code>top</code> and <code>man</code> that need to
    control the terminal do not work.  Only programs that perform
    input/output via standard input, standard output and standard
    error, etc. work well.
  </li>
  <li>
    Since the shell buffer is made completely of text, all text
    editing commands of Emacs work seamlessly on the buffer.
  </li>
  <li>
    We can take the cursor to absolutely anywhere in the buffer and
    type <code>RET</code> to execute whatever is on that line as a
    shell command.  Shell prompt on the line is automatically excluded
    from the command to be executed.
  </li>
</ul>
<p>
  Here are some key bindings that work in the shell buffer:
</p>
<ul>
  <li>
    <code>M-p</code>: Cycle backwards through input history.
  </li>
  <li>
    <code>M-n</code>: Cycle forwards through input history.
  </li>
  <li>
    <code>C-&lt;up&gt;</code>: Same as <code>M-p</code>.  May not work
    if the desktop environment gobbles up this keystroke.
  </li>
  <li>
    <code>C-&lt;down&gt;</code>: Same as <code>M-n</code>.  May not
    work if the desktop environment gobbles up this keystroke.
  </li>
  <li>
    <code>M-r f..</code>: Search history backwards for all commands
    that match the pattern <code>f..</code>.  Within the search, we
    can use incremental search key bindings
    like <code>C-r</code>, <code>C-s</code>, etc. to search backward,
    forward, etc. respectively.
  </li>
  <li>
    <code>C-c C-p</code>: Move to the previous prompt.  The cursor
    moves to the place just after the prompt.
  </li>
  <li>
    <code>C-c C-n</code>: Move to the next prompt.
  </li>
  <li>
    <code>C-c C-s out.txt RET</code>: Write output since the last
    input to a file.  Any prompt at the end of the output is not
    written.  Note that by default the output on shell contains the
    input command as well.  The input command is echoed back, so our
    input command appears twice in the buffer: once where we typed it
    and once more echoed just before the beginning of the output.
    This echoed input command is also saved to the file.
  </li>
  <li>
    <code>C-c C-o</code>: Delete all output since the last input.  Any
    prompt is of course left intact.
  </li>
  <li>
    <code>C-u C-c C-o</code>: Delete all output since the last input
    and save it to the kill ring.
  </li>
  <li>
    <code>C-c C-l</code>: Show the list of recent inputs in
    the <code>*Input History*</code> buffer.
  </li>
  <li>
    <code>C-d</code>: If the cursor is at the end of the buffer and
    there is no input, send EOF.  Otherwise delete a character forward.
  </li>
  <li>
    <code>C-c C-z</code>: Suspend the current job.  This performs the
    same function as <code>C-z</code> in the underlying shell.  We can
    then use job control commands like <code>bg</code>
    or <code>fg</code> to resume the job as a background process or
    foreground process.
  </li>
  <li>
    <code>TAB</code>: Perform completion at point.
  </li>
</ul>
<h3 id="m-x-ansi-term">M-x ansi-term</h3>
<p>
  The key sequence <code>M-x ansi-term RET RET</code> launches an
  ANSI-capable terminal emulator.  It can run sophisticated programs
  like <code>top</code>, <code>man</code>, etc. that require terminal
  capabilities fine.  The following key sequences are useful in this
  terminal emulator:
</p>
<ul>
  <li>
    <code>C-c C-j</code>: Switch to line ("cooked") sub-mode.  Emacs
    editing key sequences work normally in this mode,
    except <code>RET</code> which sends the current line as a command
    to the underlying shell.
  </li>
  <li>
    <code>C-c C-k</code>: Switch to char ("raw") sub-mode.  By
    default, the terminal starts in this mode.  Each character we type
    in this sub-mode is sent directly to the shell, except for the
    escape character <code>C-c</code> which is used as the prefix keys
    for the key sequences described in this list.
  </li>
  <li>
    <code>C-c C-c</code>: Interrupt the current subjob.
  </li>
</ul>
<h3 id="m-x-eshell">M-x eshell</h3>
<p>
  The key sequence <code>M-x eshell RET</code> creates an interactive
  Eshell buffer if none exists or switches to an existing one.  Eshell
  is implemented in Elisp.  It provides Elisp implementation of Unix
  commands like <code>ls</code>, <code>cp</code>, etc.
</p>
<p>
  The list below provides examples of some commands we can enter
  directly into Eshell:
</p>
<ul>
  <li>
    <code>which ls</code>: The output should show that <code>ls</code>
    is an Elisp function.
  </li>
  <li>
    <code>which which</code>: The output should show
    that <code>which</code> itself is an Elisp function.
  </li>
  <li>
    <code>which top</code>: The output should show the file path of
    the external program <code>top</code>.
  </li>
  <li>
    <code>ls -l</code>: Run Eshell's implementation of <code>ls</code>
    written in Elisp.
  </li>
  <li>
    <code>find-file /etc/hosts</code>: Run the Elisp function
    named <code>find-file</code> with the
    argument <code>/etc/hosts</code> thus opening the file in a
    buffer.
  </li>
  <li>
    <code>/bin/ls -l</code>: Run the external command <code>ls</code>
    available provided by the operating system utilities.
  </li>
  <li>
    <code>python3 --version</code>: Run the external
    program <code>python3</code>.
  </li>
  <li>
    <code>top</code>: Start the program <code>top</code> in a separate
    buffer with <code>term-mode</code> as the major mode.
  </li>
</ul>
<p>
  In the last point we see that for programs like <code>top</code>
  which need terminal capabilities to show output in a visual fashion
  (as opposed to just printing output to standard output or standard
  error), Eshell automatically runs the program in
  a <code>term-mode</code> buffer, so that the output of the visual
  program can be handled and displayed correctly.  Eshell looks at the
  list in the variable <code>eshell-visual-commands</code> to
  determine if a command needs terminal support or not.  By default,
  commands like <code>vi</code>, <code>screen</code>,
  <code>tmux</code>, <code>top</code>, etc. belong to this list.
</p>
