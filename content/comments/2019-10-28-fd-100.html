<!-- date: 2019-10-28 05:52:53 +0000 -->
<!-- name: Michiel Trimpe -->
<!-- url: https://twitter.com/mtrimpe -->
<!-- source: https://news.ycombinator.com/item?id=21383797 -->
<p>
  Logo was the best!
</p>
<p>
  I still remember my father ‘explaining’ me Pythagoras theorem when I
  was around 5 to show me how to draw the roof of a house on our
  hand-soldered Philips Apple II clone.
</p>
<p>
  I've been hooked ever since.
</p>
<p>
  The best thing was that 25 years later I opened a Logo emulator
  again and when faced with having to clean the screen somewhere deep,
  deep from my muscle memory the right command sprang
  forward: <code>CLEARSCREEN</code>.
</p>
<!-- date: 2019-10-28 06:21:47 +0000 -->
<!-- name: Mihir Chaturvedi -->
<!-- url: https://twitter.com/plibither8 -->
<!-- source: https://news.ycombinator.com/item?id=21374703 -->
<p>
  Oh man, PC Logo takes me back down the memory lane. We were
  introduced to PC Logo in 4th grade. That's about 9 years ago. I
  instantly fell in love with it. The amount of power I had over the
  computer - ordering it to draw what I want, how I want, was really
  exciting.
</p>
<p>
  My father had installed Kubuntu on our home computer which had an
  amazing suite of educational applications, including KTurtle which
  was (almost) the same as PC Logo. I got so addicted to it, my father
  suggested me to create a blog and regularly update it with the
  drawings and the code for
  it. <a href="http://kturtlecommands.blogspot.com/">And so I did!</a>
  Good times :).
</p>
<!-- date: 2019-10-28 06:42:18 +0000 -->
<!-- name: Wiz21C -->
<!-- source: https://news.ycombinator.com/item?id=21374775 -->
<p>
  In the same vein:
</p>
<pre><code>CALL -151</code></pre>
<p>
  That was the entry point to Apple 2's "monitor", i.e., bare bones
  assembler. Not the most beautiful but very evocative. Gave me a
  sense of power. :-)
</p>
<!-- date: 2019-10-28 11:21:44 +0000 -->
<!-- name: 8LJF -->
<!-- source: https://news.ycombinator.com/item?id=21375934 -->
<p>
  The true beauty of Logo comes in the realization that you can add
  your own words to it, and that all these specialist words you devise
  are themselves first-class citizens of the language, of syntax and
  status equal to its generic builtins. For example:
</p>
<pre>
<code>TO CIRCLE
REPEAT 360 [FD 1 RT 1]
END

TO FLOWER
REPEAT 20 [CIRCLE RT 18]
END</code>
</pre>
<p>
  And so on ad infinitum, until you arrive at a complete custom
  vocabulary that concisely and precisely expresses the particular
  concepts and behaviors of interest and importance to you. In doing
  so, you move from thinking algorithmically (which is glorified
  spaghetti) to thinking compositionally, which is the key to
  scalability – managing complexity as your needs and ambitions grow.
</p>
<p>
  Whereas Algol-y languages treat user-defined vocabulary as
  second-class citizens, beneath their own privileged built-ins. Which
  is a ridiculous status when you consider which is actually important
  to the user: precise, powerful, tailored words that describe their
  particular problem, or the crude primitive undifferentiated building
  blocks that the language dumps out of the box?
</p>
<p>
  The beauty of bottom-up programming, as any Lisp fule know :), is
  that it endlessly tests your own understanding of the problem
  domain: to define effective, productive words you must have some
  idea of what you're talking about; you can't help but learn the
  foundations of the problem space as you go. There's a basic humility
  to this approach; there’s nowhere to hide laziness or ignorance.
</p>
<p>
  Whereas in top-down programming it's much too easy for
  highly-educated highly-paid absolute know-nothings to bullshit
  eternally, constructing great theatrical class architectures; grand
  mechanical castles in the sky that look all very difficult and
  impressive to observers while never saying anything relevant or
  useful.
</p>
<p>
  That key switch from algorithmic to compositional thinking is not a
  natural conceptual leap for self-learners – it takes a carefully
  directed prod at a particular point in the learning curve to jump
  those rails – but it opens up worlds. #PlatosCave
</p>
<!-- date: 2019-10-28 13:50:12 +0000 -->
<!-- name: Mike -->
<!-- source: https://news.ycombinator.com/item?id=21376944 -->
<p>
  For all you Logo fans out there, you should really
  play <em>Duskers</em>. It's "<em>Logo</em> meets <em>Aliens</em>".
</p>
<!-- date: 2019-10-30 12:37:07 +0000 -->
<!-- name: Jerome JH -->
<!-- source: https://news.ycombinator.com/item?id=21396943 -->
<p>
  How my, so many souvenirs. Especially the one when our teacher took
  us to the courtyard and had us do the turtle in real life, him
  giving the instructions.
</p>
<!-- date: 2020-09-07 23:37:27 +0000 -->
<!-- name: DPisfun0nufispd -->
<!-- source: https://www.reddit.com/r/programming/comments/ioawe1/_/g4e2biq/ -->
<p>
  Thanks for sharing. What a cool story! That must have been a unique
  time to grow up. Going through adolescence a decade later, computers
  and the software they ran had advanced significantly enough that the
  thought of trying to code anything at that age was never even
  considered.
</p>
<p>
  Your story helped me live through that era vicariously and I can
  imagine it would have been fascinating to my younger self as well.
</p>
<!-- date: 2020-09-08 05:30:52 +0000 -->
<!-- name: Dhghomon -->
<!-- source: https://www.reddit.com/r/programming/comments/ioawe1/_/g4ez4zt/ -->
<blockquote>
  <pre><code>REPEAT 20 [REPEAT 180 [FD 1 RT 2] RT 18]</code></pre>
</blockquote>
<p>
  It's a great image because it reminds me exactly of what we used to
  do, especially the <code>RT 2</code> instead of <code>RT 1</code> to
  avoid repeating 360 times since the circle looks the same anyway on
  those monitors. Once you move up to <code>RT 3</code> or more it
  begins to look a bit more like a polygon.
</p>
