<!-- date: 2025-11-21 10:53:01 +0000 -->
<!-- name: Isogash -->
<!-- source: https://www.reddit.com/r/programming/comments/1p2su50/comment/nq03154/ -->
<p>
  Gonna memorize this for my next technical interview so I can say
  "and then we apply the FizzBuzz formula".
</p>
<!-- date: 2025-11-21 11:58:58 +0000 -->
<!-- name: Cosmic -->
<!-- source: https://www.reddit.com/r/programming/comments/1p2su50/comment/nq0aoyx/ -->
<p>
  This is grotesque.  Love it!  &lt;3
</p>

<!-- date: 2025-11-21 12:11:32 +0000 -->
<!-- name: Tri -->
<p>
  Great!  Can it be extended to print 'Jazz' if the number is
  divisible by 7?
</p>
<!-- date: 2025-11-21 12:28:39 +0000 -->
<!-- name: Susam Pal -->
<!-- url: https://susam.net/ -->
<p>
  Yes, it is quite straightforward to extend the solution to include
  numbers divisible by 7.  The new indicator function can be defined
  like this:

  \[
    I_7(n)
    = \frac{1}{7} \sum_{k = 0}^6 e^{2 \pi i k n/7}
    = \frac{1}{7} + \frac{2}{7} \cos \left( \frac{2 \pi n}{7} \right) +
                    \frac{2}{7} \cos \left( \frac{4 \pi n}{7} \right) +
                    \frac{2}{7} \cos \left( \frac{6 \pi n}{7} \right).
  \]

  The new Fourier series is going to be:

  \[
    g(n) = I_3(n) + 2 \, I_5(n) + 4 \, I_7(n) = f(n) + 4 \, I_7(n).
  \]

  So we only need to add the new term \( 4 \, I_7(n) \) to \( f(n) \),
  which gives the new Fourier series

  \begin{align*}
    g(n) = \frac{137}{105}
           &amp;+ \frac{2}{3} \cos \left( \frac{2 \pi n}{3} \right)
           + \frac{4}{5} \cos \left( \frac{2 \pi n}{5} \right)
           + \frac{4}{5} \cos \left( \frac{4 \pi n}{5} \right) \\
           &amp;+ \frac{8}{7} \cos \left( \frac{2 \pi n}{7} \right)
           + \frac{8}{7} \cos \left( \frac{4 \pi n}{7} \right)
           + \frac{8}{7} \cos \left( \frac{6 \pi n}{7} \right).
  \end{align*}

  The indicators-based solution simply becomes:
</p>
<pre>
<code>from math import cos, pi
for n in range(1, 1001):
    s = [n, 'Fizz', 'Buzz', 'FizzBuzz', 'Jazz', 'FizzJazz', 'BuzzJazz', 'FizzBuzzJazz']
    i = (n % 3 == 0) + 2 * (n % 5 == 0) + 4 * (n % 7 == 0)
    print(s[i])</code>
</pre>
<p>
  The cosine-based solution becomes:
</p>
<pre>
<code>from math import cos, pi
for n in range(1, 1001):
    s = [n, 'Fizz', 'Buzz', 'FizzBuzz', 'Jazz', 'FizzJazz', 'BuzzJazz', 'FizzBuzzJazz']
    i = round((137 / 105) + (2 / 3) * cos(2 * pi * n / 3)
                          + (4 / 5) * cos(2 * pi * n / 5)
                          + (4 / 5) * cos(4 * pi * n / 5)
                          + (8 / 7) * cos(2 * pi * n / 7)
                          + (8 / 7) * cos(4 * pi * n / 7)
                          + (8 / 7) * cos(6 * pi * n / 7))
    print(s[i])</code>
</pre>
<p>
  The value of \( g(n) \) in the formula above (or equivalently the
  value of the variable <code>i</code> in the code) can be viewed as a
  flag in which each bit corresponds to whether \( \mathtt{Fizz} \),
  \( \mathtt{Buzz} \) or \( \mathtt{Jazz} \) appears in the \( n \)th
  term of the sequence.  All other details follow from this idea.
</p>
<!-- date: 2025-11-21 12:34:17 +0000 -->
<!-- name: Omepiet -->
<!-- source: https://www.reddit.com/r/programming/comments/1p2su50/comment/nq0fhfa/ -->
<p>
  This is morally degenerate.  Also, it works.
</p>
<!-- date: 2025-11-21 13:40:48 +0000 -->
<!-- name: ByTheNumbers10 -->
<!-- source: https://www.reddit.com/r/programming/comments/1p2su50/comment/nq0q3jm/ -->
<p>
  The things you have to do with low-level languages like math and
  VHDL.
</p>
<!-- date: 2025-11-21 16:54:51 +0000 -->
<!-- name: Jose -->
<p>
  This was a beautiful reading.  Thanks.
</p>
<!-- date: 2025-11-22 11:06:05 +0000 -->
<!-- name: Wayne -->
<p>
  Thanks, I enjoyed that!
</p>
<!-- date: 2025-11-22 20:52:13 +0000 -->
<!-- name: Jwosty -->
<!-- source: https://www.reddit.com/r/programming/comments/1p2su50/comment/nq92eeu/ -->
<p>
  This is the exactly kind of thing that should win an obfuscation
  contest.  I hate it but also I love it.
</p>
<!-- date: 2025-11-30 02:55:18 +0000 -->
<!-- name: Rowan -->
<p>
  If we don't do the simplification to make the function real valued
  based on \( n \) being an integer but instead focus on the
  complex-valued functions through to the final function (which
  coincides for integers), and plot the path in the complex plane
  (Argand diagram), we get something pretty cool and spirally that
  satisfied my need for more "intuition" on why this works.
</p>
<p>
  Even better than the static complex plane path: an animated web page
  with \( 6 \) arms rotating at different rates drawing out the path.
  Really explains why it's periodic.  It hits \( 3 \) exactly when all
  the arms are in alignment forming a straight line.
</p>
