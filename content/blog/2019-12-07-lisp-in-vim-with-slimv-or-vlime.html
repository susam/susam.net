<!-- title: Lisp in Vim with Slimv or Vlime -->
<!-- tag: technology -->

<h2 id="introduction"><a href="#introduction">Introduction</a></h2>

<p>
Fifteen years ago, writing Lisp code in Vim was an odd adventure. There
were no good plugins for Vim that assisted in structured editing of Lisp
s-expressions or allowed interactive programming by embedding a Lisp
Read-Eval-Print-Loop (REPL) or a debugger within the editor. The
situation is much better now. In the last ten years, we have seen active
development of two Vim plugins named
<a href="https://github.com/kovisoft/slimv">Slimv</a> and
<a href="https://github.com/l04m33/vlime">Vlime</a>.
Slimv is over 10 years old now. Vlime is more recent and less than 3
years old right now. Both support interactive programming in Lisp.
</p>

<p>
I am going to discuss and compare both Slimv and Vlime in this article.
I will show how to get started with both plugins and introduce some of
their basic features. I will not cover everything though. This is not a
tutorial. For tutorials, see the <a
href="#references"><em>References</em></a> section.
</p>

<p>
If you are looking only for a comparison of the two plugins or a quick
recommendation, jump directly to the <a
href="#comparison-of-slimv-and-vlime"><em>Comparison of Slimv and
Vlime</em></a> section or the <a href="#quick-recommendation"><em>Quick
Recommendation</em></a> section.
</p>


<h2 id="contents"><a href="#contents">Contents</a></h2>

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#background">Background</a>
    <ul>
      <li><a href="#lisp">Lisp</a></li>
      <li><a href="#emacs-slime">Emacs: SLIME</a></li>
      <li><a href="#vim-slimv-vlime">Vim: Slimv/Vlime</a></li>
    </ul>
  </li>
  <li><a href="#vim-plugin-management">Vim Plugin Management</a></li>
  <li><a href="#software-versions">Software Versions</a></li>
  <li><a href="#get-started">Get Started</a>
    <ul>
      <li><a href="#get-started-with-slimv-and-sbcl">Get Started with Slimv and SBCL</a></li>
      <li><a href="#get-started-with-vlime-and-sbcl">Get Started with Vlime and SBCL</a></li>
      <li><a href="#get-started-with-paredit">Get Started with Paredit</a></li>
    </ul>
  </li>
  <li><a href="#use-debugger-and-inspector">Use Debugger and Inspector</a>
    <ul>
      <li><a href="#use-debugger-and-inspector-with-slimv">Use Debugger and Inspector with Slimv</a></li>
      <li><a href="#use-debugger-and-inspector-with-vlime">Use Debugger and Inspector with Vlime</a></li>
    </ul>
  </li>
  <li><a href="#trace-function">Trace Function</a>
    <ul>
      <li><a href="#trace-function-in-slimv">Trace Function in Slimv</a></li>
      <li><a href="#trace-function-in-vlime">Trace Function in Vlime</a></li>
    </ul>
  </li>
  <li><a href="#nifty-features">Nifty Features</a>
    <ul>
      <li><a href="#evaluate-top-level-form">Evaluate Top-Level Form</a>
      <li><a href="#rainbow-parentheses">Rainbow Parentheses</a>
      <li><a href="#argument-list">Argument List</a>
      <li><a href="#omni-completion">Omni-Completion</a>
      <li><a href="#describe-symbol">Describe Symbol</a>
      <li><a href="#expand-macro">Expand Macro</a>
      <li><a href="#cross-reference">Cross Reference</a>
    </ul>
  </li>
  <li><a href="#other-common-lisp-implementations">Other Common Lisp Implementations</a>
    <ul>
      <li><a href="#use-slimv-with-clisp">Use Slimv with CLISP</a></li>
      <li><a href="#use-slimv-with-ecl">Use Slimv with ECL</a></li>
      <li><a href="#use-vlime-with-clisp">Use Vlime with CLISP</a></li>
      <li><a href="#use-vlime-with-ecl">Use Vlime with ECL</a></li>
    </ul>
  </li>
  <li><a href="#other-lisp-dialects">Other Lisp Dialects</a>
    <ul>
      <li><a href="#use-slimv-with-mit-gnu-scheme">Use Slimv with MIT/GNU Scheme</a></li>
      <li><a href="#use-slimv-with-clojure">Use Slimv with Clojure</a></li>
    </ul>
  </li>
  <li><a href="#comparison-of-slimv-and-vlime">Comparison of Slimv and Vlime</a></li>
  <li><a href="#quick-recommendation">Quick Recommendation</a></li>
  <li><a href="#references">References</a></li>
</ul>


<h2 id="background"><a href="#background">Background</a></h2>

<p>
Before we get started with Slimv and Vlime, it would be nice to take a
brief look at the heritage behind these plugins. These plugins provide
Lisp development environments for Vim, so their story begins with Lisp.
</p>


<h3 id="lisp"><a href="#lisp">Lisp</a></h3>

<p>
Lisp is a family of programming languages with a distinctive, fully
parenthesized prefix notation. It is quite unlike most of the other
popular programming languages today like C, Python, Ruby, etc. Its
homoiconic nature and its powerful macro system that can transform
arbitrary Lisp expressions make it such a flexible, versatile,
extensible, and introspective language that articles describing Lisp
often have the word "enlightenment" in them. For example, see the
following articles:
</p>

<ul>
  <li>
    <a href="http://www.paulgraham.com/avg.html"><em>Beating the
    Averages</em></a> (by Paul Graham)
  </li>
  <li>
    <a href="https://www.defmacro.org/ramblings/lisp.html"><em>The
    Nature of Lisp</em></a> (by Slava Akhmechet)
  </li>
  <li>
    <a href="https://twobithistory.org/2018/10/14/lisp.html"><em>How
    Lisp Became God's Own Programming Language</em></a> (by Sinclair
    Target)
  </li>
</ul>

<p>
Lisp has been described in various ways by various eminent personalities
in the history of computing. Alan Kay has famously described Lisp as:
</p>

<blockquote>
The greatest single programming language ever designed.
</blockquote>

<p>
John Foderaro has written this about Lisp:
</p>

<blockquote>
Lisp is a programmable programming language.
</blockquote>

<p>
Eric S. Raymond has expressed the enlightenment one experiences by
learning Lisp in his famous article titled
<a href="http://www.catb.org/~esr/faqs/hacker-howto.html"><em>How To
Become A Hacker</em></a>:
</p>

<blockquote>
Lisp is worth learning for the profound enlightenment experience you
will have when you finally get it. That experience will make you a
better programmer for the rest of your days, even if you never actually
use Lisp itself a lot.
</blockquote>

<p>
Randall Munroe, the creator of the <a href="https://xkcd.com/">XKCD</a>
webcomic has dedicated two comic strips to Lisp:
</p>

<figure class="soft">
  <img src="../../files/blog/xkcd-224-lisp.jpg" alt="XKCD comic on Lisp"
       title="Original title text: We lost the documentation on quantum mechanics. You'll have to decode the regexes yourself.">
  <figcaption>
    <em>Lisp</em> by Randall Munroe
    (Source: <a href="https://xkcd.com/224/">https://xkcd.com/224/</a>)
  </figcaption>
</figure>

<figure class="soft">
  <img src="../../files/blog/xkcd-297-lisp-cycles.png" alt="XKCD comic on Lisp Cycles"
       title="Original title text: I've just received word that the Emperor has dissolved the MIT computer science program permanently.">
  <figcaption>
    <em>Lisp Cycles</em> by Randall Munroe
    (Source: <a href="https://xkcd.com/297/">https://xkcd.com/297/</a>)
  </figcaption>
</figure>

<p>
Developed in 1958 by John McCarthy, Lisp is the second oldest
programming language in use today. Only Fortran is older, by one year.
There are three Lisp dialects popular today: Common Lisp, Scheme, and
Clojure. Most of this article would focus on Common Lisp. Scheme and
Clojure would be discussed briefly towards the end of this article.
</p>


<h3 id="emacs-slime"><a href="#emacs-slime">Emacs: SLIME</a></h3>

<p>
Many Lisp programmers immediately think of Emacs when they think of
writing Lisp code. Emacs is a family of text editors. An Emacs editor
itself is typically implemented in a dialect of Lisp. There is an Emacs
mode named SLIME that provides excellent support for programming in
Lisp. SLIME stands for Superior Lisp Interaction Mode for Emacs. First
released in August 2003, SLIME was created by Eric Marsden and then
later developed further by Luke Gorrie and Helmut Eller. It offers a
Read-Eval-Print-Loop (REPL), integrated debugging, and interactive
evaluation of expressions, all available right within the editor. There
are several nifty key bindings available to compile and evaluate parts
or whole of the code in the current buffer.
</p>

<p>
SLIME works by launching a Swank TCP server. Swank is a backend server
program written in Common Lisp that listens on a socket to receive SLIME
commands from Emacs and execute them. SLIME is so useful that it is
considered to be indispensible by Lisp programmers while writing Lisp
code in Emacs.
</p>


<h3 id="vim-slimv-vlime"><a
 href="#vim-slimv-vlime">Vim: Slimv/Vlime</a></h3>

<p>
Is there anything similar to SLIME for Vim? Yes, there are two popular
options:
</p>

<ul>
  <li>
    <p>
      <strong>Slimv:</strong> It stands for Superior Lisp Interaction
      Mode for Vim. It is a Vim plugin created by Tamas Kovacs that was
      first released in January 2009.
    </p>
  </li>
  <li>
    <p>
      <strong>Vlime:</strong> It is a Vim plugin created by Kay Z that
      was first released in May 2017. It is much more recent than Slimv.
      Vlime is younger than Slimv by eight years.
    </p>
  </li>
</ul>

<p>
Both plugins use a client-server architecture like SLIME does in Emacs.
Both plugins rely on Swank server to be started. In fact, Slimv bundles
a slightly modified version of Swank with it, so that it can launch it
and connect to it to send expressions to be evaluated. Vlime does not
bundle Swank server with itself but it provides a wrapper that
automatically downloads Swank server when needed.
</p>


<h2 id="vim-plugin-management"><a
 href="#vim-plugin-management">Vim Plugin Management</a></h2>

<p>
When I started using Vim fifteen years ago, we used to just download a
Vim plugin and copy/extract it to <code>~/.vim</code> directory. These
days, there are a few plugin management tools for Vim such as <a
href="https://github.com/tpope/vim-pathogen">Pathogen</a>, <a
href="https://github.com/VundleVim/Vundle.Vim">Vundle</a>, <a
href="https://github.com/junegunn/vim-plug">vim-plug</a>, etc. I am not
going to use any of them because I don't know which one of them you use
and I don't want to write down steps for each one of them.
</p>

<p>
In fact, I don't use any Vim plugin manager myself. Until Vim 7, I used
to create a <code>~/.vim/bundle</code> directory, then copy each plugin
to its own directory within it, and add the plugin's directory path to
Vim's <code>runtimepath</code> option.
</p>

<p>
Vim 8 has native support for packages which makes installing plugins and
loading them simpler. With Vim 8, I copy each plugin to its own
directory within <code>~/.vim/pack/plugins/start</code> and they are
loaded automatically when Vim starts. The directory name
<code>plugins</code> in this path is only an example. It could be any
arbitrary name and Vim would still load the plugins fine.
</p>

<p>
In this article, I will use Vim 8's native support for packages to set
up Vim plugins. The only exception to this would be installing Vlime.
The top-level directory of Vlime is not the plugin directory. The plugin
directory is contained in a subdirectory named <code>vim</code>. This
does not conform to the directory structure of plugins in a Vim package.
Therefore, in this article, I will set up Vlime in the old fashioned way
by copying it to <code>~/.vim/bundle</code> and then adding the path to
its plugin directory to Vim's <code>runtimepath</code> option.
</p>


<h2 id="software-versions"><a
 href="#software-versions">Software Versions</a></h2>

<p>
Since this article involves several layers of software, some of what is
written here may not hold good in future as these various pieces of
software change and evolve over time. Therefore, in this subsection, I
will note down the versions of various software tools I used while
writing this article. Here they are:
</p>

<ul>
  <li>Debian GNU/Linux 10.1 (buster)</li>
  <li>Vim 8.1</li>
  <li>
    Slimv (Git repo last updated on 30 Nov 2019 with commit
    <a href="https://github.com/kovisoft/slimv/commits/47a0070">47a0070</a>)
  </li>
  <li>
    Vlime (Git repo last updated on 16 Oct 2017 with commit
    <a href="https://github.com/l04m33/vlime/commits/065b95f">065b95f</a>)
  </li>
  <li>
    Paredit (Git repo last updated on 30 Nov 2019 with commit
    <a href="https://github.com/kovisoft/paredit/commits/d99905a">d99905a</a>)
  </li>
  <li>
    Rainbow Parentheses
    (Git repo last updated on 29 Oct 2015 with commit
    <a href="https://github.com/junegunn/rainbow_parentheses.vim/commits/27e7cd7">27e7cd7</a>)
  </li>
  <li>SBCL 1.4.16.debian</li>
  <li>GNU CLISP 2.49.92</li>
  <li>ECL 16.1.3</li>
  <li>MIT/GNU Scheme 9.1.1 on Debian GNU/Linux 9.11 (stretch)</li>
  <li>Clojure 1.10.1</li>
  <li>Quicklisp beta (libraries last updated on 30 Nov 2019)</li>
  <li>tmux 2.8</li>
</ul>

<p>
You will probably need only a tiny subset of the tools above depending
on which sections in this article you would follow. Just pick the
sections you want to try out and follow the steps written in them. They
will walk you through the procedure to install the tools applicable to
the sections you have picked. Regardless of which sections you pick, I
recommend that you definitely go through the three "Get Started"
subsections below. These subsections go into detail about some of the
prerequisites such as support for tmux, Paredit, support for Python
interface in Vim, etc. that are not covered in the other sections.
</p>

<p>
The choice of Debian may look like an odd one. I want the commands and
steps discussed in this article to be easily reproducible in a free and
open source operating system. Debian happens to be my favourite. What
works on Debian is easily reproducible on Ubuntu and other derivatives,
often without any changes to the steps. I believe, it will not be too
difficult to translate the steps provided for Debian to the steps that
would work on another operating system.
</p>

<p>
  Note that Quicklisp (a prerequisite for Vlime) is still beta software
  at the time of writing this article. The actual steps to install
  Quicklisp may change in future. Check
  <a href="https://www.quicklisp.org/">https://www.quicklisp.org/</a>
  for the most up-to-date instructions to install Quicklisp.
</p>


<h2 id="get-started"><a href="#get-started">Get Started</a></h2>

<h3 id="get-started-with-slimv-and-sbcl"><a
 href="#get-started-with-slimv-and-sbcl">Get Started with Slimv and SBCL</a></h3>

<p>
Here are the steps to set up Slimv and use it:
</p>

<ol>
  <li>
    <p>
      Install the tools required to set up a Common Lisp development
      environment with Slimv with this command:
    </p>
    <pre><code>sudo apt-get install vim-nox sbcl tmux git</code></pre>
    <p>
      The default Vim in Debian is <code>vim.basic</code> provided by
      the <code>vim</code> package which does not have support for
      Python interface. Slimv is written in Vim script, Lisp, and Python
      3, so it does need a Vim package that has support for Python
      interface. One such package is <code>vim-nox</code> that provides
      the <code>vim.nox</code> command. Installing it automatically
      updates the <code>vim</code> command to run <code>vim.nox</code>.
      Another such package is <code>vim-gtk</code> which additionally
      provides GUI support. The graphical Vim known as GVim can be
      launched with the <code>gvim</code> command. It runs in the
      desktop environment. I usually install <code>vim-gtk</code> on
      Debian, MacVim on macOS, and GVim on Windows because I like my
      editor to be a GUI window on the desktop. However, for the purpose
      of this article, I will stick to <code>vim-nox</code> because it
      is lightweight. All steps meant for Slimv would run equally well
      on <code>vim-gtk</code>, MacVim, and GVim.
    </p>
    <p>
      Installing tmux is optional. Slimv can launch Swank server
      automatically if Vim is running within tmux, GNU Screen, or a
      desktop environment, so if you are using GNU Screen already, you
      don't need to install tmux. Also, if you are running Slimv in a
      desktop environment, you don't really need to install either tmux
      or GNU Screen, although you could if you would like to see Swank
      running in a separate tmux or GNU Screen window rather than a
      separate terminal window. In this article, I am going to assume
      that Vim is running within tmux.
    </p>
    <p>
      If you are going to run Slimv in a terminal without a desktop
      environment, tmux, or GNU Screen, Swank server has to be run
      manually. Point 4 below explains how to do it.
    </p>
  </li>

  <li>
    <p>
      Installing Slimv is pretty simple. Here is how I do it:
    </p>
<pre>
<code>git clone https://github.com/kovisoft/slimv.git ~/.vim/pack/plugins/start/slimv
vim +'helptags ~/.vim/pack/plugins/start/slimv/doc' +q</code>
</pre>
    <p>
      That is it! Slimv is set up. It's that straightforward. The
      commands above show how to set up Slimv with just two shell
      commands. You could also use a Vim plugin manager to install Slimv
      for you but I am not going to cover that here.
    </p>
  </li>

  <li>
    <p>
      This is an optional step. Slimv supports starting Swank server
      automatically if you are running Vim in tmux, GNU Screen, or a
      desktop environment. To start tmux, enter this command:
    </p>
    <pre><code>tmux</code></pre>
    <p>
      If you use GNU screen or a desktop environment, you don't have to
      run tmux.
    </p>
    <p>
      If you do not use tmux, GNU Screen, or a desktop environment, then
      you must start Swank server manually as explained in the next
      point.
    </p>
  </li>

  <li>
    <p>
      This step is necessary only if you are not using tmux, GNU Screen,
      or a desktop environment. The following command shows how to start
      Swank server manually:
    </p>
    <pre><code>sbcl --load ~/.vim/pack/plugins/start/slimv/slime/start-swank.lisp</code></pre>
    <p>
      If you are using tmux, GNU Screen, or a desktop environment, Slimv
      can start Swank server automatically when needed and you don't
      need to perform this step.
    </p>
  </li>

  <li>
    <p>
      Create a new Lisp source code file, say, <code>foo.lisp</code>
      with this command:
    </p>
    <pre><code>vim foo.lisp</code></pre>
  </li>

  <li>
    <p>
      To connect to Swank server, enter the following command in normal
      mode:
    </p>
    <p>
      <kbd>,</kbd><kbd>c</kbd>
    </p>
    <p>
      If Vim is running within tmux, GNU Screen, or desktop environment,
      Slimv would automatically launch Swank server and connect to it.
    </p>
    <p>
      After Slimv connects to Swank successfully, Vim window should
      split into two and the following prompt should appear in the
      new split window:
    </p>
    <pre><samp>CL-USER&gt;</samp></pre>
    <p>
      This is the integrated REPL. It is now alive and ready for
      interactive programming.
    </p>
  </li>

  <li>
    <p>
      Type some code into the buffer for the new file. To do so, first
      press <kbd>i</kbd> to enter insert mode and type this code:
    </p>
    <pre><code>(format t "hello, world~%")</code></pre>
    <p>
      Press <kbd>esc</kbd> to return to normal mode.
    </p>
  </li>
  <li>
    <p>
      To evaluate the current expression under the cursor, enter the
      following command in normal mode:
    </p>
    <p>
      <kbd>,</kbd><kbd>e</kbd>
    </p>
    <p>
      Both the current expression and its result should appear in the
      REPL window.
    </p>
  </li>

  <li>
    <p>
      The REPL is interactive. Press
      <kbd>ctrl</kbd>&nbsp;+&nbsp;<kbd>w</kbd>&nbsp;<kbd>w</kbd> to
      switch to the REPL window. Then press <kbd>i</kbd> to enter insert
      mode and type this code:
    </p>
    <pre><code>(+ 1 2)</code></pre>
    <p>
      Press <kbd>enter</kbd> to evaluate the expression just like you
      would do in a real REPL. The result should then appear in the
      REPL.
    </p>
    <p>
      Press <kbd>esc</kbd> to return to normal mode again. Use the
      normal mode command
      <kbd>ctrl</kbd>&nbsp;+&nbsp;<kbd>w</kbd>&nbsp;<kbd>w</kbd> to
      switch between the split windows.
    </p>
  </li>

  <li>
    <p>
      Now that you have got started with Slimv, here is a brief note on
      uninstallation, in case you ever need it. If Slimv is installed as
      described in point 2 above, enter the following command to
      uninstall it:
    </p>
    <pre><code>rm -rf ~/.vim/pack/plugins/start/slimv</code></pre>
  </li>
</ol>

<p>
In steps 7 and 9 of the previous section, you may have noticed that as
soon as you type an opening parenthesis or double quotation mark, a
matching closing one is automatically inserted. That is done by the <a
href="https://github.com/kovisoft/paredit">Paredit</a> plugin which is
bundled along with Slimv. Paredit ensures structured editing of Lisp
s-expressions and keeps all matched characters (parentheses, brackets,
braces, quotes) balanced. It also provides many new keybindings to edit
s-expressions conveniently. We will look into Paredit in a little more
detail in the <a href="#get-started-with-paredit"><em>Get Started with
Paredit</em></a> subsection later.
</p>


<h3 id="get-started-with-vlime-and-sbcl"><a
 href="#get-started-with-vlime-and-sbcl">Get Started with Vlime and SBCL</a></h3>

<p>
  Here are the steps to set up Vlime and use it:
</p>

<ol>

  <li>
    <p>
      Install the tools required to set up a Common Lisp development
      environment with Vlime with this command:
    </p>
    <pre><code>sudo apt-get install vim sbcl git curl</code></pre>
    <p>
      Note that unlike Slimv, Vlime can work with the default Vim in
      Debian, i.e., <code>vim.basic</code>. Vlime does not require Vim
      with Python interface.
    </p>
  </li>

  <li>
    <p>
      Install Quicklisp with these commands:
    </p>
<pre>
<code>curl -O https://beta.quicklisp.org/quicklisp.lisp
sbcl --load quicklisp.lisp --eval '(quicklisp-quickstart:install)' --eval '(exit)'
sbcl --load ~/quicklisp/setup.lisp --eval '(ql:add-to-init-file)' --eval '(exit)'</code>
</pre>
    <p>
      Press <kbd>enter</kbd> in the end, when prompted, to complete the
      installation.
    </p>
  </li>

  <li>
    <p>
      Install Vlime and Paredit with these commands:
    </p>
<pre>
<code>git clone https://github.com/l04m33/vlime.git ~/.vim/bundle/vlime
git clone https://github.com/kovisoft/paredit ~/.vim/pack/plugins/start/paredit
echo 'set runtimepath^=~/.vim/bundle/vlime/vim' &gt;&gt; ~/.vimrc
vim +'helptags ~/.vim/bundle/vlime/vim/doc' +'helptags ~/.vim/pack/plugins/start/paredit/doc' +q</code>
</pre>
    <p>
      Unlike Slimv, Vlime does not bundle <a
      href="https://github.com/kovisoft/paredit">Paredit</a> along with
      itself. As explained in the previous section, it helps us with
      structured editing of Lisp s-expressions.
    </p>
    <p>
      You should really install Paredit but in case you choose not to,
      ensure that loading of filetype plugins is enabled by entering the
      <code>:filetype</code> command in command-line mode. The output
      should contain <code>plugin:ON</code>. If it is off, add the
      command <code>filetype plugin on</code> to <code>~/.vimrc</code>
      to ensure that this is always on. Vlime won't work without this
      being enabled. If you install Paredit, you don't have to bother
      about this because Paredit takes care of enabling this by default.
    </p>
  </li>

  <li>
    <p>
    <p>
      Create a new Lisp source code file, say, <code>foo.lisp</code>
      with this command:
    </p>
    <pre><code>vim foo.lisp</code></pre>
  </li>

  <li>
    <p>
      To start Vlime server (a wrapper around Swank server) and connect
      to it automatically, enter the following command in normal mode:
    </p>
    <p>
      <kbd>\</kbd><kbd>r</kbd><kbd>r</kbd>
    </p>
    <p>
      We assume here that Vim <code>&lt;LocalLeader&gt;</code> is left
      to its default, i.e., backslash. If it is mapped to some
      other key combination, then that must be used instead of
      backslash in the above command.
    </p>
    <p>
      The first time this command is run after installing Vlime, it
      installs Swank server using Quicklisp. Therefore, it can take a
      while for Vlime server to start the first time this command is
      run. On subsequent use of these commands, it would start faster
      because it would be already installed.
    </p>
    <p>
      The console output from Vlime server is displayed in a split
      window. After Vlime successfully connects to Swank, the following
      message is displayed at the bottom:
    </p>
    <pre><samp>Vlime Connection 1 established.</samp></pre>
    <p>
      After the above message appears, it is okay to close the split
      window for Vlime server by entering this command in Vim
      command-line mode:
    </p>
    <pre><code>:q</code></pre>
    <p>
      Vlime server would continue to run in background. The following
      command can be used in normal mode to view the console output of
      Vlime server anytime it is required:
    </p>
    <p>
      <kbd>\</kbd><kbd>r</kbd><kbd>v</kbd>
    </p>
  </li>

  <li>
    <p>
      Type some code into the buffer for the new file. To do so, first
      press <kbd>i</kbd> to enter insert mode and type this code:
    </p>
    <pre><code>(format t "hello, world~%")</code></pre>
    <p>
      Press <kbd>esc</kbd> to return to normal mode.
    </p>
  <li>
    <p>
      To evaluate, the current expression under the cursor, enter the
      following command in normal mode:
    </p>
    <p>
      <kbd>\</kbd><kbd>s</kbd><kbd>s</kbd>
    </p>
    <p>
      Both the current expression and its result should appear in the
      REPL window.
    </p>
    <p>
      Unlike Slimv, the REPL window of Vlime is <em>not</em>
      interactive. Its <code>nomodifiable</code> option is set, so we
      cannot type code directly into the REPL window. This can be a bit
      of a problem if we want to type arbitrary expressions into the
      REPL and execute them. To mitigate this shortcoming to some
      extent, Vlime provides an alternative way to evaluate the current
      expression known as the interaction mode. This is explained in the
      next point.
    </p>
  </li>

  <li>
    <p>
      Enable interaction mode by entering this command in normal
      mode:
    </p>
    <p><kbd>\</kbd><kbd>i</kbd></p>
    <p>
      The same command disables interaction mode, i.e., this command
      toggles the state of interaction mode between on and off. When
      interaction mode is on, evaluate an expression under the cursor by
      simply pressing <kbd>enter</kbd> in normal mode.
    </p>
  </li>

  <li>
    <p>
      Now that you have got started with Vlime, here is a brief note on
      uninstallation, in case you ever need it. If Quicklisp and Vlime
      are installed as described in the points 2 and 3 above, run these
      commands to uninstall them:
    </p>
<pre>
<code>rm -rf ~/quicklisp ~/.vim/bundle/vlime ~/.vim/pack/plugins/start/paredit
sed -i.bkp '/runtimepath.*vlime/d' ~/.vimrc</code>
</pre>
    <p>
      Optionally, remove <code>~/.sblrc</code> or edit it to remove the
      code pertaining to loading <code>quicklisp/setup.lisp</code>.
  </li>
</ol>


<h3 id="get-started-with-paredit"><a
 href="#get-started-with-paredit">Get Started with Paredit</a></h3>

<p>
You have already got started with Paredit when you wrote Lisp code while
following one of the previous two subsections. The moment you typed an
opening parenthesis, Paredit inserted a closing one for you
automatically. Paredit keeps all matched characters such as parentheses,
double quotes, etc. balanced when you edit code. Here is a very brief
exercise to quickly get started with some of the very basic features of
Paredit:
</p>

<ol>
  <li>
    <p>
      Create a new Lisp source code file, say, <code>foo.lisp</code>
      with this command:
    <p>
    <pre><code>vim foo.lisp</code></pre>
  </li>

  <li>
    <p>
      Press <kbd>i</kbd> to enter insert mode and then type only this:
    </p>
    <pre><code>(defun square (x</code></pre>
    <p>
      At this point, Paredit should have inserted the two closing
      parentheses automatically. The code should look like this:
    </p>
    <pre><code>(defun square (x<span class="cursor">)</span>)</code></pre>
    <p>
      The cursor should be situated just after the parameter
      <code>x</code>. The underbar above shows where the cursor should
      be.
    </p>
  </li>

  <li>
    <p>
      While you are still in insert mode, type the first closing
      parenthesis. Yes, type it even if the closing parenthesis is
      already present. The cursor should now skip over the first closing
      parenthesis like this:
    </p>
    <pre><code>(defun square (x)<span class="cursor">)</span></code></pre>
    <p>
      Of course, there was no need to type the closing parenthesis
      because it was already present but typing it out to skip over
      it is more efficient than escaping to normal mode, then moving
      over it, and then entering insert mode again. This is, in fact, a
      very nifty feature of Paredit. We can enter code with the same
      keystrokes as we would without Paredit.
    </p>
  </li>

  <li>
    <p>
      You should still be in insert mode. Press <kbd>enter</kbd> to
      create a new line below. Now one of two things are going to
      happen. If electric return is disabled, then a newline is inserted
      as expected like this:
    </p>
<pre>
<code>(defun square (x))
  <span class="cursor">)</span></code>
</pre>
  <p>
      If electric return is enabled, two newlines are inserted
      to create an empty line in between:
    </p>
<pre>
<code>(defun square (x)
  <span class="cursor"> </span>
  )</code>
</pre>
    <p>
      In both cases, indentation of two spaces is inserted
      automatically. The new empty line inserted by electric return
      allows linewise editing of the code to be entered in this empty
      line.
    </p>
    <p>
      The electric return feature is enabled by default in both Paredit
      and Slimv. It works by Paredit remapping the "enter" key
      (<code>&lt;CR&gt;</code>) in insert mode to a function that
      inserts electric return. Slimv needs to remap the "enter" key to
      present the argument list of the current function but it takes
      care of performing an electric return before showing the argument
      list. Vlime, however, forgets to perform electric return before
      showing the argument list, so this feature does not work in Vlime.
    </p>
    <p>
      For now, we will continue with the assumption that electric return
      is enabled and working fine. If it is disabled or if it is not
      working for you, ignore the steps that discuss electric return.
    </p>
  </li>

  <li>
    <p>
      Now, type only this:
    </p>
    <pre><code>(* x x</code></pre>
    <p>
      Again, Paredit would have inserted the closing parenthesis
      automatically. The code should look like this now:
    </p>
<pre>
<code>(defun square (x)
  (* x x<span class="cursor">)</span>
  )</code>
</pre>
  </li>

  <li>
    <p>
      Now, type one more closing parenthesis to advance past the
      automatically inserted closing parenthesis like this:
    </p>
<pre>
<code>(defun square (x)
  (* x x)<span class="cursor"> </span>
  )</code>
</pre>
  </li>

  <li>
    <p>
      Then type another closing parenthesis. Paredit would now pick the
      lone closing parenthesis that is present in its own line and move
      it at the end of the current line like this:
    </p>
<pre>
<code>(defun square (x)
  (* x x))<span class="cursor"> </span></code>
</pre>
    <p>
      This behaviour of consuming the extra newline inserted by an
      electric return on typing a closing parenthesis helps the code to
      conform to the popular Lisp coding convention of putting all the
      consecutive closing parentheses next to each other in the same
      line. In other words, typing closing parentheses re-gathers
      electric returns when applicable.
    </p>
  </li>

  <li>
    <p>
      Let us see what happens if we try to delete the opening
      parenthesis around the product function (the <code>*</code>
      function). Press <kbd>esc</kbd> to return to normal mode. Then
      enter <kbd>h</kbd> in normal mode to move the cursor one place
      left so that the cursor is placed just after the last
      <code>x</code> in the code like this:
    </p>
<pre>
<code>(defun square (x)
  (* x x<span class="cursor">)</span>)</code>
</pre>
    <p>
      Now enter <kbd>(</kbd> in normal mode to move the cursor to the
      opening parenthesis of the product function call like this:
    </p>
<pre>
<code>(defun square (x)
  <span class="cursor">(</span>* x x))</code>
</pre>
    <p>
      Press <kbd>x</kbd> to delete the opening parenthesis. Nothing gets
      deleted! Instead the cursor just skips over the opening
      parenthesis like this:
    </p>
<pre>
<code>(defun square (x)
  (<span class="cursor">*</span> x x))</code>
</pre>
    <p>
      Paredit refuses to delete the opening parenthesis
      because it encloses a non-empty list. It would have deleted the
      opening parenthesis along with the closing one if the list were
      empty. This is Paredit trying to ensure that the s-expressions
      remain valid while editing.
    </p>
    <p>
      Note that in this step, <kbd>h</kbd> is a regular Vim motion
      command. In Vim, by default, <kbd>(</kbd> moves the cursor one
      sentence backward and <kbd>x</kbd> deletes the character under the
      cursor, but when Paredit is enabled, it remaps these commands to
      behave the way they did in this step.
    </p>
  </li>

  <li>
    <p>
      Let us now try to delete the current line. Press
      <kbd>d</kbd><kbd>d</kbd> to do so. The result looks like this:
    </p>
<pre>
<code>(defun foo (x)
  <span class="cursor">)</span></code>
</pre>
    <p>
      Note how the closing parenthesis has been left intact to keep the
      parentheses balanced. Again, Paredit has remapped the
      <kbd>d</kbd><kbd>d</kbd> command to produce this behaviour.
    </p>
  </li>

</ol>

<p>
That was a very brief overview of what Paredit can do. There is a lot
more to Paredit than what is described above. Paredit has a rich set of
keybindings to make editing s-expressions very convenient. Enter
<code>:help paredit-keys</code> in command-line mode to see the list of
the keybindings.
</p>

<p>
I think it is a good idea to read the entire Paredit documentation.
Enter <code>:help paredit</code> to do so. It is about 500 lines long
and takes about 30 to 40 minutes to read. The time spent reading this
documentation is worth it because it makes editing Lisp code very
pleasant and productive.
</p>


<h2 id="use-debugger-and-inspector"><a
 href="#use-debugger-and-inspector">Use Debugger and Inspector</a></h2>

<p>
After getting started with Slimv or Vlime, the very next thing you might
want to know is how to work with the debugger. The debugger window comes
up whenever an error or an unhandled condition occurs. It might look
quite scary to a beginner, so it is a good idea to become comfortable
with it as soon as possible. Fortunately, both Slimv and Vlime provide
excellent key-bindings to inspect the error or dismiss it to return to
the source code buffer quickly and easily.
</p>


<h3 id="use-debugger-and-inspector-with-slimv"><a
 href="#use-debugger-and-inspector-with-slimv">Use Debugger and Inspector with Slimv</a></h3>

<p>
The following steps trigger an error and then show how to work with the
debugger in Slimv:
</p>

<ol>
  <li>
    <p>
      Create a file with Vim, say <code>foo.lisp</code> and enter the
      following code into it:
    </p>
<pre>
<code>(defun square (x)
  (* x x))

(square "foo")</code>
</pre>
  </li>

  <li>
    <p>
      Enter <kbd>,</kbd><kbd>b</kbd> to evaluate the buffer.
    </p>
  </li>

  <li>
    <p>
      As soon as the defective form <code>(square "foo")</code> gets
      evaluated, an error occurs. The error, possible restarts, and the
      backtrace is displayed in a new split window for SLDB. SLDB stands
      for Slime Debugger. Here is an example of what may appear in the
      SLDB window:
    </p>
<pre>
<samp>The value
  "foo"
is not of type
  NUMBER
when binding SB-KERNEL::X
   [Condition of type TYPE-ERROR]

Restarts:
  0: [RETRY] Retry SLIME REPL evaluation request.
  1: [*ABORT] Return to SLIME's top level.
  2: [ABORT] abort thread (#<THREAD "repl-thread" RUNNING {1003274E23}>)

Backtrace:
  0: (SB-KERNEL:TWO-ARG-* "foo" "foo") [external]
  1: (SQUARE "foo")
  2: (SB-DEBUG::TRACE-CALL #<SB-DEBUG::TRACE-INFO SQUARE> #<FUNCTION SQUARE> "foo")
  3: (SB-INT:SIMPLE-EVAL-IN-LEXENV (SQUARE "foo") #<NULL-LEXENV>)
  4: (EVAL (SQUARE "foo"))
  5: (SWANK::EVAL-REGION "(defun square (x) ..)
  6: ((LAMBDA NIL :IN SWANK-REPL::REPL-EVAL))
  ...</samp>
</pre>
    <p>
      The ellipsis in the end is added by me to denote that the actual
      output has been truncated in this article for the sake of brevity.
    </p>
  </li>

  <li>
    <p>
      In the SLDB window, move the cursor to the second line of
      backtrace, i.e., on the following line:
    </p>
    <pre><samp>  1: (SQUARE "foo")</samp></pre>
    <p>
      Then press <kbd>enter</kbd>. This line should now unfold to
      show the following details:
    </p>
<pre>
<samp>  1: (SQUARE "foo")
      in "(SB-INT:NAMED-LAMBDA SQUARE-----------------------------------
    Locals:
      X = "foo"</samp>
</pre>
  </li>

  <li>
    <p>
      Move the cursor to the line that begins with <code>in</code>,
      i.e., the following line:
    </p>
    <pre><samp>      in "(SB-INT:NAMED-LAMBDA SQUARE-----------------------------------</samp></pre>
    <p>
      Then press <kbd>enter</kbd>. Some information about its source
      code should appear like this:
    </p>
<pre>
<samp>  1: (SQUARE "foo")
      in "(SB-INT:NAMED-LAMBDA SQUARE
    (X)
  (BLOCK SQUARE (#:***HERE*** (* X X))))" byte 1
    Locals:
      X = "foo"</samp>
</pre>
  </li>

  <li>
    <p>
      Move the cursor to the following line:
    </p>
    <pre><samp>      X = "foo"</samp></pre>
    <p>
      Then press <kbd>,</kbd><kbd>i</kbd> to inspect this variable. A
      prompt would appear to confirm the variable name. Press
      <kbd>enter</kbd> to confirm. An inspector window should now
      appear with more details about this variable. This window should
      look like this:
    </p>
<pre>
<samp>Inspecting #<(SIMPLE-ARRAY CHARACTER (3)) {100478AFAF}>
--------------------
Press <F1> for Help

Dimensions: (3)
Element type: CHARACTER
Total size: 3
Adjustable: NIL
Fill pointer: NIL
Contents:
0: #\f
1: #\o
2: #\o


[&lt;&lt;] Exit Inspector</samp>
</pre>
  </li>

  <li>
    <p>
      Press <kbd>enter</kbd> to inspect any object under the cursor and
      drill down further.
    </p>
  </li>

  <li>
    <p>
      Press <kbd>backspace</kbd> in normal mode to return to the
      previous object.
    </p>
  </li>

  <li>
    <p>
      Enter <kbd>,</kbd><kbd>q</kbd> in normal mode to quit the
      inspector.
    </p>
  </li>

  <li>
    <p>
      Finally, move the cursor to the following line in the SLDB window:
    </p>
    <pre><samp>  1: [*ABORT] Return to SLIME's top level.</samp></pre>
    <p>
      Then press <kbd>enter</kbd> to execute this restart.
      Alternatively, enter <kbd>,</kbd><kbd>a</kbd> in normal mode to
      select the abort restart and quit to the previous level or
      <kbd>,</kbd><kbd>q</kbd> to quit to top level.
    </p>
  </li>
</ol>

<p>
Most of the times when an error occurs, I quickly take a look at the
stack trace to realize that I have made a silly mistake and enter the
<kbd>,</kbd><kbd>q</kbd> command to abort and quit to top level. This is
one of my most favourite commands in Slimv because it allows me to
return from debugging to coding really fast with only two keystrokes.
</p>


<h3 id="use-debugger-and-inspector-with-vlime"><a
 href="#use-debugger-and-inspector-with-vlime">Use Debugger and Inspector with Vlime</a></h3>

<p>
The following steps trigger an error and then show how to work with the
debugger in Vlime:
</p>

<ol>
  <li>
    <p>
      Create a file with Vim, say <code>foo.lisp</code> and enter the
      following code into it:
    </p>
<pre>
<code>(defun square (x)
  (* x x))

(square "foo")</code>
</pre>
  </li>

  <li>
    <p>
      Save the file, connect to Vlime server, and enter
      <kbd>\</kbd><kbd>o</kbd><kbd>f</kbd> in normal mode to compile the
      entire buffer.
    </p>
  </li>

  <li>
    <p>
      As soon as the defective form <code>(square "foo")</code> gets
      evaluated, an error occurs. The error, possible restarts, and the
      backtrace is displayed in a new split window for SLDB. SLDB stands
      for Slime Debugger. Here is an example of what may appear in the
      SLDB window:
    </p>
<pre>
<samp>Thread: 1; Level: 1

The value
  "foo"
is not of type
  NUMBER
when binding SB-KERNEL::X
   [Condition of type TYPE-ERROR]

Restarts:
  0. *ABORT - Return to SLIME's top level.
  1.  ABORT - abort thread (#<THREAD "worker" RUNNING {10045D6F83}>)

Frames:
  0.  (SB-KERNEL:TWO-ARG-* "foo" "foo") [external]
  1.  (SQUARE "foo")
  2.  (SB-FASL::LOAD-FASL-GROUP #S(SB-FASL::FASL-INPUT :STREAM #<SB-SYS:FD-STREAM for "file /home/susam/foo.fasl" {10045E76A3}> :TABLE #(41 #<PACKAGE "SB-IMPL"> SB-IMPL::%DEFUN #<PACKAGE "COMMON-LISP-USER">..
  3.  (SB-FASL::LOAD-AS-FASL #<SB-SYS:FD-STREAM for "file /home/susam/foo.fasl" {10045E76A3}> NIL NIL)
  4.  ((FLET SB-FASL::THUNK :IN LOAD))
  5.  (SB-FASL::CALL-WITH-LOAD-BINDINGS #<CLOSURE (FLET SB-FASL::THUNK :IN LOAD) {7F7B9B0B60BB}> #<SB-SYS:FD-STREAM for "file /home/susam/foo.fasl" {10045E76A3}>)
  ...</samp>
</pre>
    <p>
      The ellipsis in the end is added by me to denote that the actual
      output has been truncated in this article for the sake of brevity.
    </p>
  </li>

  <li>
    <p>
      In the SLDB window, move the cursor to the second line of
      backtrace, i.e., on the following line:
    </p>
    <pre><samp>  1.  (SQUARE "foo")</samp></pre>
    <p>
      Then press <kbd>d</kbd>. A new split window should appear with the
      following details about this frame:
    </p>
<pre>
<samp>Frame: 1 (Restartable)

Locals:
  X: "foo"

Location:
  File: /home/susam/foo.lisp
  Position: 20
  Snippet:
    (* x x))

    (square "foo")</samp>
</pre>
  </li>

	<li>
		<p>
      While the cursor is on the same line as mentioned in the previous
      point, press <kbd>i</kbd> to bring up the inspector window for
      this frame.
		</p>
	</li>

  <li>
    <p>
      In the inspector window, press <kbd>i</kbd> to enter insert mode.
      Enter the following variable name in insert mode:
    </p>
    <pre><code>x</code></pre>
    <p>
      Then press <kbd>esc</kbd> to return to normal mode. Then press
      <kbd>enter</kbd>. The following details about the variable
      <code>x</code> should now appear in the inspector window:
    </p>
    <p>
<pre>
<samp>#<(SIMPLE-ARRAY CHARACTER (3)) {1004617ABF}>
============================================

Dimensions: (3)
Element type: CHARACTER
Total size: 3
Adjustable: NIL
Fill pointer: NIL
Contents:
0: #\f
1: #\o
2: #\o</samp></pre>
  </li>

  <li>
    <p>
      Press <kbd>enter</kbd> to inspect any object under the cursor and
      drill down further.
    </p>
  </li>

  <li>
    <p>
      Press <kbd>p</kbd> to return to the previous object.
    </p>
  </li>

  <li>
    <p>
      Enter the regular Vim command <code>:q</code> in command-line mode
      to quit the inspector window.
    </p>
  </li>

  <li>
    <p>
      Finally, move the cursor to the following line in the SLDB window:
    </p>
    <pre><samp>  1: [*ABORT] Return to SLIME's top level.</samp></pre>
    <p>
      Then press <kbd>enter</kbd> to execute this restart.
      Alternatively, we can enter <kbd>a</kbd> in normal mode to
      select the abort restart to return to the previous level. At this
      time, there is no command to return to SLIME's top level.
    </p>
  </li>

</ol>


<h2 id="trace-function"><a
 href="#trace-function">Trace Function</a></h2>

<h3 id="trace-function-in-slimv"><a
 href="#trace-function-in-slimv">Trace Function in Slimv</a></h3>

<p>
The following steps show how to get started with tracing functions in
Slimv:
</p>

<ol>
  <li>
    <p>
      Create a file with Vim, say <code>foo.lisp</code> and enter the
      following code into it:
    </p>
<pre>
<code>(defun square (x)
  (* x x))

(square (square 2))</code>
</pre>
  </li>

  <li>
    <p>
      Enter <kbd>,</kbd><kbd>b</kbd> in normal mode to evaluate the
      entire buffer.
    </p>
  </li>

  <li>
    <p>
      Place the cursor on the function name, i.e., on
      <code>square</code>, and enter <kbd>,</kbd><kbd>t</kbd> in normal
      mode to toggle tracing for this function. A prompt appears to
      confirm the function name. Press <kbd>enter</kbd> to confirm.
    </p>
  </li>

  <li>
    <p>
      While the cursor is on the last expression, enter
      <kbd>,</kbd><kbd>d</kbd> in normal mode to evaluate the top-level
      form. The following output appears in the REPL buffer.
    </p>
<pre>
<code>(square (square 2))
  0: (SQUARE 2)
  0: SQUARE returned 4
  0: (SQUARE 4)
  0: SQUARE returned 16
16</code>
</pre>
    <p>
      This output contains information about each call to the traced
      function, arguments passed to it, and the return values.
    </p>
  </li>
</ol>


<h3 id="trace-function-in-vlime"><a
 href="#trace-function-in-vlime">Trace Function in Vlime</a></h3>

<p>
It takes a little more work to start tracing functions in Vlime. The
following steps show how to do it:
</p>

<ol>
  <li>
    <p>
      Add the following statement to <code>~/.vimrc</code>:
    </p>
<pre>
<code>let g:vlime_contribs = ['SWANK-ASDF', 'SWANK-PACKAGE-FU',
                      \ 'SWANK-PRESENTATIONS', 'SWANK-FANCY-INSPECTOR',
                      \ 'SWANK-C-P-C', 'SWANK-ARGLISTS', 'SWANK-REPL',
                      \ 'SWANK-FUZZY', 'SWANK-TRACE-DIALOG']</code>
</pre>
    <p>
      The above variable defines the list of Swank contrib modules to
      load while initializing a Vlime connection. All modules mentioned
      above except the last one are loaded by default. The
      <code>SWANK-TRACE-DIALOG</code> module is not loaded by default
      but this module is necessary for tracing functions, so in order to
      load it, we define this variable to load this module in addition
      to all the other modules that are loaded by default.
    </p>
  </li>

  <li>
    <p>
      Create a file with Vim, say <code>foo.lisp</code> and enter the
      following code into it:
    </p>
<pre>
<code>(defun square (x)
  (* x x))

(square (square 2))</code>
</pre>
  </li>

  <li>
    <p>
      Save the file, connect to Vlime server, and enter
      <kbd>\</kbd><kbd>o</kbd><kbd>f</kbd> in normal mode to compile the
      entire buffer.
    </p>
  </li>

  <li>
    <p>
      Enter <kbd>\</kbd><kbd>T</kbd><kbd>D</kbd> in normal mode to show
      the trace dialog in a split window.
    </p>
  </li>

  <li>
    <p>
      Enter <kbd>ctrl</kbd>&nbsp;+&nbsp;<kbd>w</kbd>&nbsp;<kbd>w</kbd>
      in normal mode to go back to the source code window.
    </p>
  </li>

  <li>
    <p>
      Place the cursor on the function name, i.e., on
      <code>square</code>, and enter
      <kbd>\</kbd><kbd>T</kbd><kbd>T</kbd> in normal mode to toggle
      tracing for this function.
    </p>
  </li>

  <li>
    <p>
      While the cursor is on the last expression, enter
      <kbd>\</kbd><kbd>s</kbd><kbd>t</kbd> in normal mode to evaluate
      the top-level form.
    </p>
  </li>

  <li>
    <p>
      Enter <kbd>ctrl</kbd>&nbsp;+&nbsp;<kbd>w</kbd>&nbsp;<kbd>w</kbd>
      in normal mode twice to go to the trace window.
    </p>
  </li>

  <li>
    <p>
      Under <code>Trace Entries</code>, place the cursor on
      <code>[refresh]</code> and press <kbd>enter</kbd>.
    </p>
  </li>

  <li>
    <p>
      Then place the cursor on <code>[fetch next batch]</code> and press
      <kbd>enter</kbd>. Two results should appear for the two
      <code>square</code> calls that were made due to step 7. The trace
      information would be folded under each call.
    </p>
  </li>

  <li>
    <p>
      Move the cursor to each fold line and enter
      <kbd>z</kbd><kbd>o</kbd> in normal mode to open the fold. After
      opening both the folds, the following result should be visible:
    </p>
    <pre>
<code>0 - COMMON-LISP-USER::SQUARE
    &gt; 2
    &lt; 4
1 - COMMON-LISP-USER::SQUARE
    &gt; 4
    &lt; 16
    16</code>
</pre>
    <p>
      The lines starting with <code>&gt;</code> show the arguments and
      the ones starting with <code>&lt;</code> show the return values.
    </p>
  </li>
</ol>



<h2 id="nifty-features"><a
 href="#nifty-features">Nifty Features</a></h2>

<p>
In this section, we will go over some of the nifty features that these
plugins offer. Not all features will be covered here. I have chosen only
a few features for the discussion here that I felt would be useful to
beginners and at the same time also demonstrate the versatility of these
plugins.
</p>


<h3 id="evaluate-top-level-form"><a
 href="#evaluate-top-level-form">Evaluate Top-Level Form</a></h3>

<p>
In the previous sections, we saw how to evaluate the current expression
under the cursor. In this section, we will see how to evaluate the
top-level expression around the current cursor position. Let us do a
small exercise to see this:
</p>

<ol>
  <li>
    <p>
      Create a file with Vim, say <code>foo.lisp</code> and enter the
      following code into it:
    </p>
    <pre><code>(+ 1 (* 2 (/ 6 <span class="cursor">2</span>)))</code></pre>
  </li>

  <li>
    <p>
      With Slimv or Vlime connected to Swank, let us do a quick recap of
      how to evaluate the current expression.
    </p>
    <p>
      With Slimv, enter the normal mode command <kbd>,</kbd><kbd>e</kbd>
      to evaluate the current expression.
    </p>
    <p>
      With Vlime, enter the normal mode command
      <kbd>\</kbd><kbd>s</kbd><kbd>s</kbd> to evaluate the current
      expression.
    </p>
    <p>
      The current expression, i.e., <code>(/ 6 2)</code> should get
      evaluated and the result <code>3</code> should appear in the REPL
      buffer.
    </p>
  </li>

  <li>
    <p>
      Let us now see how to evaluate the top-level expression.
    </p>
    <p>
      With Slimv, enter the normal mode command <kbd>,</kbd><kbd>d</kbd>
      to evaluate the top-level expression.
    </p>
    <p>
      With Vlime, enter the normal mode command
      <kbd>\</kbd><kbd>s</kbd><kbd>t</kbd> to evaluate the top-level
      expression.
    </p>
    <p>
      The top-level expression should get evaluated and the result
      <code>7</code> should appear in the REPL buffer.
    </p>
  </li>
</ol>


<h3 id="rainbow-parentheses"><a
 href="#rainbow-parentheses">Rainbow Parentheses</a></h3>

<p>
Rainbow parentheses make it easy to see matching parentheses by
colouring different levels of parentheses with different colours.
Matching parentheses have the same colour. To enable this feature in
Slimv, add this command to <code>~/.vimrc</code>:
</p>

<pre><code>let g:lisp_rainbow=1</code></pre>

<p>
This feature is not available in Vlime. But there are several Vim
plugins that support rainbow parentheses. Here are the steps to install
one such plugin that is quite popular:
</p>

<pre>
<code>git clone https://github.com/junegunn/rainbow_parentheses.vim.git ~/.vim/pack/plugins/start/rainbow_parentheses
echo 'autocmd FileType lisp,scheme,clojure RainbowParentheses' &gt;&gt; ~/.vimrc</code>
</pre>

<p>
In case you ever want to uninstall it, enter these commands:
</p>

<pre>
<code>rm -rf ~/.vim/pack/plugins/start/rainbow_parentheses
sed -i.bkp '/autocmd.*RainbowParentheses/d' ~/.vimrc</code>
</pre>


<h3 id="argument-list"><a
 href="#argument-list">Argument List</a></a></h3>

<p>
You must have seen this feature already while trying out the sections
earlier. While editing a Lisp source file, after typing a function name,
as soon as a space is typed or the enter key is pressed, the argument
list for the function appears to serve as a reference. In Slimv, the
argument list appears in the status line at the bottom. In Vlime, the
argument list appears in a split window at the top.
</p>


<h3 id="omni-completion"><a
 href="#omni-completion">Omni-Completion</a></h3>

<p>
Type a function name partially, e.g., <code>form</code>, and press
<kbd>tab</kbd> while still in insert mode. The omni-completion menu
should appear with the list of completions if there are multiple
choices. Press <kbd>ctrl</kbd>+<kbd>n</kbd> to select the next choice
and <kbd>ctrl</kbd>+<kbd>p</kbd> to select the previous choice.
Selecting a choice also immediately inserts that choice in the buffer.
This works in both Slimv and Vlime. In Slimv, we can also press
<kbd>tab</kbd> to select the next choice.
</p>

<p>
By default, omni-completion is fuzzy. For example, type <code>wl</code>
and press <kbd>tab</kbd> and omni-complete should insert
<code>write-line</code> automatically as well as show other matching
choices.
</p>


<h3 id="describe-symbol"><a
 href="#describe-symbol">Describe Symbol</a></h3>

<p>
With Slimv, enter the normal mode command <kbd>,</kbd><kbd>s</kbd> to
describe the symbol under the cursor. This brings up the documentation
of the symbol in the Vim message area. This feature works while editing
Common Lisp and Clojure source files but not while editing Scheme source
file. This feature is not supported for Scheme at this time. See the <a
href="#other-lisp-dialects"><em>Other Lisp Dialects</em></a> section for
details on how to set up Slimv with Clojure and MIT/GNU Scheme.
</p>

<p>
With Vlime, enter <kbd>\</kbd><kbd>d</kbd><kbd>a</kbd> in normal mode to
describe the symbol under the cursor. This brings up the documentation
of the symbol in a split window.
</p>


<h3 id="expand-macro"><a
 href="#expand-macro">Expand Macro</a></h3>

<p>
Here is an excercise that shows how to expand macros interactively while
editing a Lisp source file:
</p>

<ol>
  <li>
    <p>
      Create a file with Vim, say <code>foo.lisp</code> and enter the
      following code into it:
    </p>
<pre>
<code>(defmacro calc (a op b)
  (list op a b))

(defmacro square (x)
  (list 'calc x '* x))

(square 2)</code>
</pre>
  </li>

  <li>
    <p>
      With Slimv, enter <kbd>,</kbd><kbd>b</kbd> in normal mode to
      evaluate the entire buffer.
    </p>
    <p>
      With Vlime, save the file, connect to Vlime server, and press
      <kbd>\</kbd><kbd>o</kbd><kbd>f</kbd> in normal mode to compile the
      entire buffer.
    </p>
  </li>

  <li>
    <p>
      With Slimv, while the cursor is on the last expression, enter
      <kbd>,</kbd><kbd>1</kbd> in normal mode to expand the macro form
      once.
    </p>
    <p>
      With Vlime, enter <kbd>\</kbd><kbd>m</kbd><kbd>1</kbd> in normal
      mode to do the same thing.
    </p>
    <p>
      The following expansion should appear as the result:
    </p>
    <pre><code>(CALC 2 * 2)</code></pre>
    <p>
      Slimv displays the expansion in the REPL buffer whereas Vlime
      displays it in a new split window.
    </p>
  </li>

  <li>
    <p>
      With Slimv, enter <kbd>,</kbd><kbd>m</kbd> in normal mode to
      recursively expand the current expression until it is no longer a
      macro.
    </p>
    <p>
      With Vlime, enter <kbd>\</kbd><kbd>m</kbd><kbd>a</kbd> in
      normal mode to do the same thing.
    </p>
    <p>
      The following expansion should appear as the result:
    </p>
    <pre><code>(* 2 2)</code></pre>
  </li>
</ol>


<h3 id="cross-reference"><a
 href="#cross-reference">Cross Reference</a></h3>

<p>
Here is an exercise that shows how to use the cross-reference commands
in Slimv and Vlime:
</p>

<ol>
  <li>
    <p>
      Create a file with Vim, say <code>foo.lisp</code> and enter the
      following code into it:
    </p>
<pre>
<code>(defun square (x)
  (* x x))

(defun square-of-sum (x y)
  (square (+ x y)))

(defun sum-of-squares (x y)
  (+ (square x) (square y)))

(square-of-sum 2 3)
(sum-of-squares 2 3)</code>
</pre>
  </li>

  <li>
    <p>
      With Slimv, enter <kbd>,</kbd><kbd>b</kbd> in normal mode to
      evaluate the entire buffer.
    </p>
    <p>
      With Vlime, save the file, connect to Vlime server, and press
      <kbd>\</kbd><kbd>o</kbd><kbd>f</kbd> in normal mode to compile the
      entire buffer.
    </p>
  </li>

  <li>
    <p>
      With Slimv, place the cursor on any occurrence of the symbol
      <code>square</code> and enter <kbd>,</kbd><kbd>x</kbd><kbd>l</kbd>
      in normal mode. A prompt would appear to confirm the symbol name.
      Press <kbd>enter</kbd> to confirm. The list of all callers should
      now appear in the REPL buffer.
    </p>
    <p>
      With Vlime, place the cursor on any occurrence of the symbol
      <code>square</code> and enter <kbd>\</kbd><kbd>x</kbd><kbd>c</kbd>
      in normal mode to list all callers of the function. The output
      appears in a split window containing the cross reference (xref)
      buffer. Press <kbd>enter</kbd> on any item in the xref buffer and
      Vlime will take you directly to the referenced location.
    </p>
  </li>
</ol>


<h2 id="other-common-lisp-implementations"><a
 href="#other-common-lisp-implementations">Other Common Lisp Implementations</a></h2>

<p>
The previous sections used SBCL as the implementation of Common Lisp.
How well do Slimv and Vlime work with other Common Lisp implementations?
</p>

<p>
I have found that both plugins are pretty well tested with SBCL.
However, they may not be so well tested with other implementations. Due
to the lack of sufficient testing with Common Lisp implementations other
than SBCL, certain errors may occur while using other implementations.
Sometimes it is possible to work around these errors and sometimes it
isn't. We will see an example of this in an upcoming section when we try
to start Swank server automatically using Vlime and CLISP.
</p>

<p>
For this section, I choose CLISP and Embeddable Common-Lisp (ECL) as two
other implementations of Common Lisp that will be used with Slimv and
Vlime. After following the upcoming subsections, you should get the hang
of how to make Slimv or Vlime work with other implementations of Common
Lisp.
</p>


<h3 id="use-slimv-with-clisp"><a
 href="#use-slimv-with-clisp">Use Slimv with CLISP</a></h3>

<p>
If you have read and tried the steps in the
<a href="#get-started-with-slimv-and-sbcl"><em>Get Started with Slimv
and SBCL</em></a> section, it is going to be quite easy to use Slimv
with CLISP. The steps are similar with a few minor modifications. They
are explained below:
</p>

<ol>
  <li>
    <p>
      Uninstall SBCL and install CLISP with these commands:
    </p>
    <pre>
<code>sudo apt-get remove sbcl
sudo apt-get install clisp</code></pre>
  </li>

  <li>
    <p>
      To start Swank server manually, enter this command:
    </p>
    <pre><code>clisp ~/.vim/pack/plugins/start/slimv/slime/start-swank.lisp</code></pre>
    <p>
      Then edit a Lisp source file and enter the normal command
      <kbd>,</kbd><kbd>c</kbd> to connect to it and bring up the REPL
      window.
    </p>
  </li>

  <li>
    <p>
      To start Swank automatically from Slimv, there is nothing more to
      be done. Just edit a Lisp source file and enter the normal mode
      command <kbd>,</kbd><kbd>c</kbd>. While running in GNU Screen,
      tmux, or a desktop environment, Slimv can automatically detect
      CLISP and start Swank server with it.
    </p>
  </li>
</ol>

<p>
  In general, to start Swank server manually with another Common Lisp
  implementation, we need to figure out how to load
  <code>start-swank.lisp</code> with it.
</p>


<h3 id="use-slimv-with-ecl"><a
 href="#use-slimv-with-ecl">Use Slimv with ECL</a></h3>

<p>
The steps to use Slimv with Embeddable Common-Lisp (ECL) are very
similar too. Once again, only if we need to start Swank server manually,
we need to figure out the command to do so. Otherwise, there is no other
difference. Here are the steps:
</p>

<ol>
  <li>
    <p>
      Ensure that SBCL and CLISP are uninstalled and ECL is installed.
    </p>
    <pre>
<code>sudo apt-get remove sbcl clisp
sudo apt-get install ecl</code></pre>
  </li>

  <li>
    <p>
      To start Swank server manually, enter this command:
    </p>
    <pre><code>ecl --load ~/.vim/pack/plugins/start/slimv/slime/start-swank.lisp</code></pre>
    <p>
      Then edit a Lisp source file and enter the normal command
      <kbd>,</kbd><kbd>c</kbd> to connect to it and bring up the REPL
      window.
    </p>
  </li>

  <li>
    <p>
      To start Swank automatically from Slimv, there is nothing more to
      be done. Just edit a Lisp source file and enter the normal mode
      command <kbd>,</kbd><kbd>c</kbd>. While running in GNU Screen,
      tmux, or a desktop environment, Slimv can automatically detect
      CLISP and start Swank server with it.
    </p>
    <p>
      There is a possible timeout issue to be aware of though. ECL can
      take a minute or two to compile the code it loads the first time
      Swank server is started. However, Slimv has a default timeout
      period of 20 seconds, so Slimv may fail with the following error
      message:
    </p>
    <pre><samp>SWANK server is not running. Press ENTER to continue.</samp></pre>
    <p>
      If this happens, just wait for ECL to complete compiling Swank
      server. Once it starts Swank server, enter the normal mode command
      <kbd>,</kbd><kbd>c</kbd> again and it should connect immediately.
    </p>
  </li>
</ol>


<h3 id="use-vlime-with-clisp"><a
 href="#use-vlime-with-clisp">Use Vlime with CLISP</a></h3>

<p>
This subsection assumes that you have already read and tried the <a
href="#get-started-with-vlime-and-sbcl"><em>Get Started with Vlime and
SBCL</em></a> section, so you are familiar with Vlime basics. Now we
will see what more it takes to use Vlime with CLISP in the steps below:
</p>

<ol>
  <li>
    <p>
      Let us assume we want to start afresh with CLISP, i.e., we do not
      have previous artifacts created by SBCL. To clean up old
      artifacts, enter these commands:
    </p>

<pre>
<code>rm -rf ~/.sbclrc ~/quicklisp
sudo apt-get remove sbcl</code>
</pre>
  </li>

  <li>
    <p>
      Install CLISP with this command:
    </p>
    <pre><code>sudo apt-get install clisp</code></pre>
  </li>

  <li>
    <p>
      Install Quicklisp using CLISP with these commands:
    </p>
    <pre>
<code>curl -O https://beta.quicklisp.org/quicklisp.lisp
clisp -i quicklisp.lisp -x '(quicklisp-quickstart:install)'
clisp -i ~/quicklisp/setup.lisp -x '(ql:add-to-init-file)'</code>
</pre>
    <p>
      Press <kbd>enter</kbd> in the end, when prompted, to complete the
      installation.
    </p>
  </li>

  <li>
    <p>
      Add the following code to <code>~/.vimrc</code>:
    </p>
<pre>
<code>let g:vlime_cl_impl = 'clisp'
function! VlimeBuildServerCommandFor_clisp(vlime_loader, vlime_eval)
    return ['clisp', '-i', a:vlime_loader,
                   \ '-x', a:vlime_eval,
                   \ '-repl']
endfunction</code>
</pre>
    <p>
      Unlike Slimv, automatic start of Swank server with Common Lisp
      implementations other than SBCL are not supported out of the box,
      so the above Vim script tells Vlime how to start Swank server with
      CLISP. The <code>-repl</code> option is used to work around an
      issue that is explained in the next point.
    </p>
  </li>

  <li>
    <p>
      Vlime is now ready to be used with CLISP. Just edit a Lisp source
      file and enter the normal mode command
      <kbd>\</kbd><kbd>r</kbd><kbd>r</kbd> to start Swank server and
      connect to it automatically.
    </p>
    <p>
      You may see the following error in the SLIME debugger (`sldb`)
      split window:
    </p>
    <pre><samp>SOCKET-STATUS on #1=#&lt;INPUT STRING-INPUT-STREAM&gt; is illegal</samp></pre>
    <p>
      Despite the above error, the following message should appear at
      the bottom:
    </p>
    <pre><samp>Vlime Connection 1 established.</samp></pre>
    <p>
      If the above message occurs, you can ignore this error, close
      the debugger window as well as the console output window, and
      continue to use Vlime normally.
    </p>
    <p>
      The <code>-repl</code> option used in the previous step ensures
      that the REPL starts despite this error. Without it, this step
      would not have succeeded. This is what I meant when I said earlier
      that we may need to work around certain errors while using these
      plugins with a Common Lisp implementation other than SBCL.
    </p>
  </li>
</ol>


<h3 id="use-vlime-with-ecl"><a
 href="#use-vlime-with-ecl">Use Vlime with ECL</a></h3>

<p>
Here are the steps to use Vlime with ECL:
</p>

<ol>
  <li>
    <p>
      Let us assume we want to start afresh with ECL, i.e., we do not
      have previous artifacts created by SBCL or ECL. To clean up old
      artifacts, enter these commands:
    </p>

<pre>
<code>rm -rf ~/.sbclrc ~/.clisprc.lisp ~/quicklisp
sudo apt-get remove sbcl clisp</code>
</pre>
  </li>

  <li>
    <p>
      Install ECL with this command:
    </p>
    <pre><code>sudo apt-get install ecl</code></pre>
  </li>

  <li>
    <p>
      Install Quicklisp using ECL with these commands:
    </p>
    <pre>
<code>curl -O https://beta.quicklisp.org/quicklisp.lisp
ecl --load quicklisp.lisp --eval '(quicklisp-quickstart:install)' --eval '(quit)'
ecl --load ~/quicklisp/setup.lisp --eval '(ql:add-to-init-file)' --eval '(quit)'</code>
</pre>
    <p>
      Press <kbd>enter</kbd> in the end, when prompted, to complete the
      installation.
    </p>
  </li>

  <li>
    <p>
      Add the following code to <code>~/.vimrc</code>:
    </p>
<pre>
<code>let g:vlime_cl_impl = 'ecl'
function! VlimeBuildServerCommandFor_ecl(vlime_loader, vlime_eval)
    return ['ecl', '--load', a:vlime_loader,
                 \ '--eval', a:vlime_eval]
endfunction</code>
</pre>
  </li>

  <li>
    <p>
      Edit a Lisp source file and enter the normal mode command
      <kbd>\</kbd><kbd>r</kbd><kbd>r</kbd> to start Swank server and
      connect to it automatically.
    </p>
  </li>
</ol>


<h2 id="other-lisp-dialects"><a
 href="#other-lisp-dialects">Other Lisp Dialects</a></h2>

<p>
So far, we saw how to use Slimv or Vlime with a Common Lisp
implementation. Now let us see how well these plugins work with other
Lisp dialects. Vlime does not support other Lisp dialects. It supports
Common Lisp only. Thankfully, Vlime supports two other popular dialects
of Lisp: Scheme and Clojure. In the next two subsections, we see how
</p>


<h3 id="use-slimv-with-mit-gnu-scheme"><a
 href="#use-slimv-with-mit-gnu-scheme">Use Slimv with MIT/GNU Scheme</a></h3>

<p>
Slimv is documented to work with MIT/GNU Scheme on Linux only. Enter
<code>:help slimv-installation</code> in Vim to read more about it. It
says the following under the "Prerequisites" section.
</p>

<blockquote>
Lisp or Clojure or MIT/GNU Scheme (Linux only) installed.
</blockquote>

<p>
Further, the Swank loader script for MIT/GNU Scheme named
<code>swank-mit-scheme.scm</code> says the following in its source code
comments:
</p>

<blockquote>
You need MIT/GNU Scheme 9.2
</blockquote>

<p>
At the time of writing this article, I have confirmed that both these
requirements indeed need to be met to use Slimv with MIT/GNU Scheme.
Here are the steps to use Slimv with MIT/GNU Scheme:
</p>

<ol>
  <li>
    <p>
      Install MIT/GNU Scheme with this command:
    </p>
    <pre><code>sudo apt-get mit-scheme</code></pre>
    <p>
      Ensure that <code>vim-nox</code>, tmux, and Slimv are
      installed as explained in the <a
      href="#get-started-with-slimv-and-sbcl"><em>Get Started with Slimv
      and SBCL</em></a> subsection earlier.
    </p>
  </li>
  <li>
    <p>
      This is an optional step. To start Swank server automatically from
      Slimv, run Vim in tmux, GNU Screen, or a desktop environment. In
      this article, we use tmux, so start tmux with this command:
    </p>
    <pre><code>tmux</code></pre>
  </li>
  <li>
    <p>
      This step is necessary only if you are not using tmux, GNU Screen,
      or a desktop environment. In such a case, enter this command to
      start Swank server manually:
    </p>
    <pre><code>scheme --load ~/.vim/pack/plugins/start/slimv/slime/contrib/swank-mit-scheme.scm</code></pre>
  </li>
  <li>
    <p>
      Create a new Scheme source code file, say, <code>foo.scm</code>
      with this command:
    </p>
    <pre><code>vim foo.scm</code></pre>
  </li>
  <li>
    <p>
      To connect to Swank server, enter the following command in Vim
      normal mode:
    </p>
    <p>
      <kbd>,</kbd><kbd>c</kbd>
    </p>
  </li>
  <li>
    <p>
      Type some code into the buffer for the new file. To do so, first
      press <kbd>i</kbd> to enter insert mode and type this code:
    </p>
<pre><code>(display "hello, world\n")</code></pre>
    <p>
    <p>
      Press <kbd>esc</kbd> to return to normal mode. To evaluate, the
      current expression under the cursor, enter the following command
      in normal mode:
    </p>
    <p>
      <kbd>,</kbd><kbd>e</kbd>
    </p>
    <p>
      Both the current expression and its result should appear in the
      REPL window.
    </p>
  </li>
</ol>

<p>
I have confirmed that the steps above work fine with MIT/GNU Scheme
9.1.1 on Debian GNU/Linux 9.11 (stretch). Like I mentioned before, Slimv
requires Linux to work with MIT/GNU Scheme. For example, trying to start
Swank server with MIT/GNU Scheme 9.2 on macOS High Sierra 10.13.6 fails
with this error:
</p>

<pre>
<samp>; /usr/local/Cellar/mit-scheme/9.2_2/lib/mit-scheme-c/include/config.h:879:10:
fatal error: 'sys/types.h' file not found</samp>
</pre>

<p>
Further, the version of MIT/GNU Scheme really needs to be 9.x. For
example, when I try to start Swank with MIT/GNU Scheme 10.1.5 on Debian
GNU/Linux 10.1 (buster), the following error occurs:
</p>

<pre>
<samp>;The object #[package 12 (user)], passed as an argument to
->environment, is not an environment.</samp>
</pre>


<h3 id="use-slimv-with-clojure"><a
 href="#use-slimv-with-clojure">Use Slimv with Clojure</a></h3>

<p>
Slimv works fine with Clojure too. However, it may have some trouble
locating Clojure on the system if we attempt to start Swank server
automatically with Clojure. That is because where and how Clojure is
installed varies from operating system to operating system and also
depends on the installation procedure chosen to set up Clojure.
</p>

<p>
On Unix-like systems, Slimv looks for JAR files that match the glob
pattern <code>clojure*.jar</code> at paths that match the glob pattern
<code>/usr/local/bin/*clojure*</code> and <code>~/*clojure</code>, in
that order. On Windows, it looks for the JAR files at directory paths
that match the glob pattern <code>C:\*clojure*</code> and
<code>C:\*clojure*\lib</code>. Additionally, Slimv also looks for the
JAR files at the paths mentioned in the <code>PATH</code> environment
variable. There are a few more strategies too to locate Clojure but we
will not get into that here.
</p>

<p>
In this section, I will show how to build Clojure from source with Maven
and install it at <code>~/clojure/clojure.jar</code>, a path Slimv can
easily find, so installing it here would mean that the steps below would
work everywhere regardless of the operating system. If you are on
Windows, install Clojure at <code>C:\clojure\clojure.jar</code> instead.
</p>

<p>
Here are the steps to install Clojure at
<code>~/clojure/clojure.jar</code> and use it with Slimv:
</p>

<ol>
  <li>
    <p>
      Choose one of the two sets of commands below to install Maven:
    </p>
<pre>
<code># On Debian, Ubuntu, etc.
sudo apt-get install maven

# On macOS
brew install openjdk maven
export JAVA_HOME=/usr/local/opt/openjdk
export PATH="$JAVA_HOME/bin:$PATH"</code>
</pre>
  </li>
  <li>
    <p>
      Enter these commands to install Clojure:
    </p>
<pre>
<code>git clone https://github.com/clojure/clojure.git ~/clojure
git -C ~/clojure checkout clojure-1.10.1
mvn -f ~/clojure/pom.xml -Plocal -Dmaven.test.skip=true package</code>
</pre>
  </li>
  <li>
    <p>
      Ensure that <code>vim-nox</code>, tmux, and Slimv are
      installed as explained in the <a
      href="#get-started-with-slimv-and-sbcl"><em>Get Started with Slimv
      and SBCL</em></a> subsection earlier.
    </p>
  </li>
  <li>
    <p>
      This is an optional step. To start Swank server automatically from
      Slimv, run Vim in tmux, GNU Screen, or a desktop environment. In
      this article, we use tmux, so start tmux with this command:
    </p>
    <pre><code>tmux</code></pre>
  </li>
  <li>
    <p>
      This step is necessary only if you are not using tmux, GNU Screen,
      or a desktop environment. In such a case, enter these commands to
      start Swank server manually:
    </p>
<pre>
<code>SWANK_DIR=~/.vim/pack/plugins/start/slimv/swank-clojure
java -cp "$HOME/clojure/clojure.jar:$SWANK_DIR" clojure.main -i "$SWANK_DIR/swank/swank.clj" -e '(swank.swank/start-repl)' -r</code>
</pre>
  </li>
  <li>
    <p>
      Create a new Clojure source code file, say, <code>foo.clj</code>
      with this command:
    </p>
    <pre><code>vim foo.clj</code></pre>
  </li>
  <li>
    <p>
      To connect to Swank server, enter the following command in Vim
      normal mode:
    </p>
    <p>
      <kbd>,</kbd><kbd>c</kbd>
    </p>
  </li>
  <li>
    <p>
      Type some code into the buffer for the new file. To do so, first
      press <kbd>i</kbd> to enter insert mode and type this code:
    </p>
<pre><code>(println "hello, world")</code></pre>
    <p>
    <p>
      Press <kbd>esc</kbd> to return to normal mode. To evaluate, the
      current expression under the cursor, enter the following command
      in normal mode:
    </p>
    <p>
      <kbd>,</kbd><kbd>e</kbd>
    </p>
    <p>
      Both the current expression and its result should appear in the
      REPL window.
    </p>
  </li>
</ol>


<h2 id="comparison-of-slimv-and-vlime"><a
 href="#comparison-of-slimv-and-vlime">Comparison of Slimv and Vlime</a></h2>

<p>
Finally, let me provide a comparison of both Slimv and Vlime side by
side. This comparison table below is not exhaustive. There are more
differences between the tools than what is mentioned below.
</p>


<table class="grid top">
  <thead>
    <tr>
      <th>Slimv</th>
      <th>Vlime</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="width: 50%">
        <p>
          Slimv's directory structure conforms to the directory
          structure of plugins in a Vim package as well as the default
          directory structure expected by popular Vim plugin managers,
          so installing Slimv is quite straightforward.
        </p>
      </td>
      <td style="width: 50%">
        <p>
          Vlime's directory structure does not conform to the directory
          structure of plugins in a Vim package or the default directory
          structure expected by popular Vim plugin managers. As a
          result, Vim's native support for packages cannot be used to
          install Vlime. Installing it via a plugin manager requires
          fiddling with Vim's <code>runtimepath</code> option in order
          to load it successfully.
        </p>
      </td>
    </tr>

    <tr>
      <td style="width: 50%">
        <p>
          Slimv requires a Vim package that is compiled with support for
          Python interface.
        </p>
      </td>
      <td style="width: 50%">
        <p>
          Vlime does not have this requirement. It can work with basic Vim
          that does not have Python interface.
        </p>
      </td>
    </tr>

    <tr>
      <td>
        <p>
          Slimv requires Vim to be running within tmux, GNU Screen, or a
          desktop environment to be able to start Swank server
          automatically. If you have none of these, Swank server needs
          to be started manually.
        </p>
      </td>
      <td>
        <p>
          Vlime does not require tmux, GNU Screen, or a desktop
          environment in order to start Vlime server automatically. It
          can start Vlime server on its own.
        </p>
      </td>
    </tr>

    <tr>
      <td>
        <p>
          Slimv does not require Quicklisp to install Swank. Slimv
          bundles the Swank server code with itself.
        </p>
      </td>
      <td>
        <p>
          Vlime requires Quicklisp to be installed. It relies on
          Quicklisp to install Swank the first time it is needed.
        </p>
      </td>
    </tr>

    <tr>
      <td>
        <p>
          Slimv bundles Paredit with itself. Installing Slimv also
          provides Paredit.
        </p>
      </td>
      <td>
        <p>
          Vlime does not bundle Paredit with itself. Paredit needs to be
          installed separately.
        </p>
      </td>
    </tr>

    <tr>
      <td>
        <p>
          The buffer for REPL is interactive in Slimv. We can type code
          directly into the REPL window and press <kbd>enter</kbd> to
          execute it.
        </p>
      </td>
      <td>
        <p>
          The buffer for REPL is not interactive in Slimv. Its
          <code>nomodifiable</code> option is set, so we cannot type
          code directly into the REPL window.
        </p>
      </td>
    </tr>

    <tr>
      <td>
        <p>
          Paredit electric returns work fine with Slimv. Slimv remaps
          the "enter" key to show argument list of the current function
          after inserting electric returns. It takes care of preserving
          the electric return functionality of Paredit.
        </p>
      </td>
      <td>
        <p>
          Paredit electric returns do not work fine with Vlime. Vlime
          remaps the "enter" key to show argument list of the current
          function without inserting electric returns.
        </p>
      </td>
    </tr>

    <tr>
      <td>
        <p>
          Slimv shows argument list of a function, symbol description,
          etc. in the status line or message area at the bottom.
        </p>
      </td>
      <td>
        <p>
          Vlime shows argument list of a function, symbol description,
          etc. in separate split windows. These are extra windows to
          skip over while cycling between windows with the normal mode
          <kbd>ctrl</kbd>&nbsp;+&nbsp;<kbd>w</kbd>&nbsp;<kbd>w</kbd>
          command which could feel inconvenient.
        </p>
      </td>
    </tr>

    <tr>
      <td>
        <p>
          Slimv shows trace results, macro expansion, cross reference,
          etc. in the REPL buffer.
        </p>
      </td>
      <td>
        <p>
          Vlime shows resultions of trace results, macro expansion,
          cross reference, etc. in split windows. These are extra
          windows to skip over while cycling between windows. This could
          feel inconvenient.
        </p>
      </td>
    </tr>

    <tr>
      <td>
        <p>
          Slimv supports programming in Common Lisp, MIT/GNU Scheme, and
          Clojure.
        </p>
      </td>
      <td>
        <p>
          Vlime supports programming in Common Lisp only. It does not
          support Scheme or Clojure.
        </p>
      </td>
    </tr>

    <tr>
      <td>
        <p>
          Slimv supports rainbow parentheses by adding
          <code>let g:lisp_rainbow=1</code> to <code>~/.vimrc</code>.
          With this feature, parentheses at different levels have
          different colours and matching parentheses have the same colour.
        </p>
      </td>
      <td>
        <p>
          Vlime does not have rainbow parentheses. However, this is not
          a major problem because there are several independent plugins
          available that provide rainbow parentheses.
        </p>
      </td>
    </tr>

    <tr>
      <td>
        <p>
          Slimv cross-reference commands do not help us to jump directly
          to a function listed in the results.
        </p>
      </td>
      <td>
        <p>
          Vlime cross-reference commands create a xref buffer that
          allows us to jump directly to a function listed in the results
          by moving the cursor to the function name in the xref buffer and pressing
          <code>enter</code>.
        </p>
      </td>
    </tr>
  </tbody>
</table>


<h2 id="quick-recommendation"><a href="#quick-recommendation">Quick Recommendation</a></h2>

<p>
If you are looking for a quick recommendation on which plugin to use, I
am going to recommend Slimv. It has been around for much longer. It
supports a wider variety of Lisp implementations. I find its default key
bindings more convenient. A truly interactive REPL buffer is also a
bonus. Also, Slimv supports Scheme and Clojure whereas Vlime does not.
</p>

<p>
I use Slimv myself. The additional dependency on Python interface for
Vim is not a problem for me because I use one of GVim, MacVim, or
vim-gtk anyway and these are compiled with support for Python interface.
</p>

<p>
Having said that, I think it is a good idea to try out both the plugins
on your own and then find out which one suits you more.
</p>


<h2 id="references"><a href="#references">References</a></h2>

<ul>
  <li>
    <a href="https://web.archive.org/web/20160303225220/http://osdir.com/ml/lisp.cmucl.devel/2003-08/msg00302.html">Couple of Emacs hacks</a>
  </li>
  <li>
    <a
    href="https://groups.google.com/forum/#!topic/vim_announce/EKTuhjF3ET0">Vim 8.0 Released</a>
  </li>
  <li>
    <a href="https://kovisoft.bitbucket.io/tutorial.html">Slimv Tutorial</a>
  </li>
  <li>
    <a href="https://github.com/l04m33/vlime/blob/master/vim/doc/vlime-tutor.txt">A Tutorial for Vlime</a>
  </li>
</ul>
