<!-- date: 2019-12-07 -->
<!-- title: Lisp in Vim -->
<!-- tag: Lisp, Programming, Vim, Technology -->
<!-- import: extra.css -->
<h2 id="introduction">Introduction</h2>
<p>
  Fifteen years ago, writing Lisp code in Vim was an odd adventure.
  There were no good plugins for Vim that assisted in structured
  editing of Lisp s-expressions or allowed interactive programming by
  embedding a Lisp Read-Eval-Print-Loop (REPL) or a debugger within
  the editor.  The situation has improved a lot since then.  In the
  last ten years, we have seen active development of two Vim plugins
  named <a href="https://github.com/kovisoft/slimv">Slimv</a> and
  <a href="https://github.com/l04m33/vlime">Vlime</a>.  Slimv is over
  10 years old now.  Vlime is more recent and less than 3 years old
  right now.  Both support interactive programming in Lisp.
</p>
<p>
  I am going to discuss and compare both Slimv and Vlime in this
  article.  I will show how to get started with both plugins and
  introduce some of their basic features.  I will not cover everything
  though.  This is not a tutorial.  For tutorials, see
  the <a href="#references"><em>References</em></a> section.
</p>
<p>
  If you are looking only for a comparison of the two plugins or a
  quick recommendation, jump directly to the
  <a href="#comparison-of-slimv-and-vlime"><em>Comparison of Slimv and Vlime</em></a>
  section or the
  <a href="#quick-recommendation"><em>Quick Recommendation</em></a>
  section.
</p>
{{ toc }}
<h2 id="background">Background</h2>
<p>
  Before we get started with Slimv and Vlime, it would be nice to take
  a brief look at the heritage behind these plugins.  These plugins
  provide Lisp development environments for Vim, so their story begins
  with Lisp.
</p>
<h3 id="lisp">Lisp</h3>
<p>
  Lisp is a family of programming languages with a distinctive, fully
  parenthesised prefix notation.  It is quite unlike most of the other
  popular programming languages today like C, Python, Ruby, etc.  Its
  homoiconic nature and its powerful macro system that can transform
  arbitrary Lisp expressions make it such a flexible, versatile,
  extensible, and introspective language that articles describing Lisp
  often have the word "enlightenment" in them.  For example, see the
  following articles:
</p>
<ul>
  <li>
    <a href="http://www.paulgraham.com/avg.html"><em>Beating the
    Averages</em></a> (by Paul Graham)
  </li>
  <li>
    <a href="https://www.defmacro.org/ramblings/lisp.html"><em>The
    Nature of Lisp</em></a> (by Slava Akhmechet)
  </li>
  <li>
    <a href="https://twobithistory.org/2018/10/14/lisp.html"><em>How
    Lisp Became God's Own Programming Language</em></a> (by Sinclair
    Target)
  </li>
</ul>
<p>
  Lisp has been described in various ways by various eminent
  personalities in the history of computing.  Alan Kay has famously
  described Lisp as:
</p>
<blockquote>
  The greatest single programming language ever designed.
</blockquote>
<p>
  John Foderaro has written this about Lisp:
</p>
<blockquote>
  Lisp is a programmable programming language.
</blockquote>
<p>
  Eric S. Raymond has expressed the enlightenment one experiences by
  learning Lisp in his famous article titled
  <a href="http://www.catb.org/~esr/faqs/hacker-howto.html"><em>How To Become A Hacker</em></a>:
</p>
<blockquote>
  Lisp is worth learning for the profound enlightenment experience you
  will have when you finally get it.  That experience will make you a
  better programmer for the rest of your days, even if you never
  actually use Lisp itself a lot.
</blockquote>
<p>
  Randall Munroe, the creator of the
  <a href="https://xkcd.com/">XKCD</a> webcomic has dedicated two
  comic strips to Lisp:
</p>
<figure class="soft">
  <img src="files/blog/xkcd-224-lisp.jpg" alt="XKCD comic on Lisp"
       title="Original title text: We lost the documentation on quantum mechanics.  You'll have to decode the regexes yourself.">
  <figcaption>
    <em>Lisp</em> by Randall Munroe
    (Source: <a href="https://xkcd.com/224/">https://xkcd.com/224/</a>)
  </figcaption>
</figure>
<figure class="soft">
  <img src="files/blog/xkcd-297-lisp-cycles.png" alt="XKCD comic on Lisp Cycles"
       title="Original title text: I've just received word that the Emperor has dissolved the MIT computer science program permanently.">
  <figcaption>
    <em>Lisp Cycles</em> by Randall Munroe
    (Source: <a href="https://xkcd.com/297/">https://xkcd.com/297/</a>)
  </figcaption>
</figure>
<p>
  Developed in 1958 by John McCarthy, Lisp is the second oldest
  programming language in use today.  Only Fortran is older, by one
  year.  There are three Lisp dialects popular today: Common Lisp,
  Scheme, and Clojure.  Most of this article would focus on Common
  Lisp.  Scheme and Clojure would be discussed briefly towards the end
  of this article.
</p>
<h3 id="emacs-slime">Emacs: SLIME</h3>
<p>
  Many Lisp programmers immediately think of Emacs when they think of
  writing Lisp code.  Emacs is a family of text editors.  An Emacs
  editor itself is typically implemented in a dialect of Lisp.  There
  is an Emacs mode named SLIME that provides excellent support for
  programming in Lisp.  SLIME stands for Superior Lisp Interaction
  Mode for Emacs.  First released in August 2003, SLIME was created by
  Eric Marsden and then later developed further by Luke Gorrie and
  Helmut Eller.  It offers a Read-Eval-Print-Loop (REPL), integrated
  debugging, and interactive evaluation of expressions, all available
  right within the editor.  There are several nifty key bindings
  available to compile and evaluate parts or whole of the code in the
  current buffer.
</p>
<p>
  SLIME works by launching a Swank TCP server.  Swank is a backend
  server program written in Common Lisp that listens on a socket to
  receive SLIME commands from Emacs and execute them.  SLIME is so
  useful that it is considered to be indispensible by many Lisp
  programmers who write Lisp code in Emacs.
</p>
<h3 id="vim-slimv-vlime">Vim: Slimv/Vlime</h3>
<p>
  Is there anything similar to SLIME for Vim?  Yes, there are two
  popular options:
</p>
<ul>
  <li>
    <p>
      <strong>Slimv:</strong> It stands for Superior Lisp Interaction
      Mode for Vim.  It is a Vim plugin created by Tamas Kovacs that
      was first released in January 2009.
    </p>
  </li>
  <li>
    <p>
      <strong>Vlime:</strong> It is a Vim plugin created by Kay Z that
      was first released in May 2017.  It is much more recent than
      Slimv.  Vlime is younger than Slimv by eight years.
    </p>
  </li>
</ul>
<p>
  Both plugins use a client-server architecture like SLIME does in
  Emacs.  Both plugins rely on Swank server to be started.  In fact,
  Slimv bundles a slightly modified version of Swank with it, so that
  it can launch it and connect to it to send expressions to be
  evaluated.  Vlime does not bundle Swank server with itself but it
  provides a wrapper that automatically downloads Swank server when
  needed.
</p>
<h2 id="vim-plugin-management">Vim Plugin Management</h2>
<p>
  When I started using Vim fifteen years ago, we used to just download
  a Vim plugin and copy/extract it to <code>~/.vim</code> directory.
  These days, there are a few plugin management tools for Vim such
  as <a href="https://github.com/tpope/vim-pathogen">Pathogen</a>,
  <a href="https://github.com/VundleVim/Vundle.Vim">Vundle</a>,
  <a href="https://github.com/junegunn/vim-plug">vim-plug</a>, etc.  I
  am not going to use any of them because I don't know which one of
  them you use and I don't want to write down steps for each one of
  them.
</p>
<p>
  In fact, I have never used any Vim plugin manager myself.  Until Vim
  7, I used to create a <code>~/.vim/bundle</code> directory, then
  copy each plugin to its own directory within it, and add the
  plugin's directory path to Vim's <code>runtimepath</code> option.
</p>
<p>
  Vim 8 has native support for packages which makes installing plugins
  and loading them simpler.  With Vim 8, we can copy each plugin to
  its own directory within <code>~/.vim/pack/plugins/start</code> and
  they are loaded automatically when Vim starts.  The directory name
  <code>plugins</code> in this path is only an example.  It could be
  any arbitrary name and Vim would still load the plugins fine.
</p>
<p>
  In this article, I will use Vim 8's native support for packages to
  set up Vim plugins.  The only exception to this would be installing
  Vlime.  The top-level directory of Vlime is not the plugin
  directory.  The plugin directory is contained in a subdirectory
  named <code>vim</code>.  This does not conform to the directory
  structure of plugins in a Vim package.  Therefore, in this article,
  I will set up Vlime in the old fashioned way by copying it
  to <code>~/.vim/bundle</code> and then adding the path to its plugin
  directory to Vim's <code>runtimepath</code> option.
</p>
<h2 id="software-versions">Software Versions</h2>
<p>
  Since this article involves several layers of software, some of what
  is written here may not hold good in future as these various pieces
  of software change and evolve over time.  Therefore, in this
  section, I will note down the versions of various software tools I
  used while writing this article.  Here they are:
</p>
<ul>
  <li>Debian GNU/Linux 10.1 (buster)</li>
  <li>Vim 8.1</li>
  <li>
    Slimv (Git repo last updated on 30 Nov 2019 with commit
    <a href="https://github.com/kovisoft/slimv/commits/47a0070">47a0070</a>)
  </li>
  <li>
    Vlime (Git repo last updated on 16 Oct 2017 with commit
    <a href="https://github.com/l04m33/vlime/commits/065b95f">065b95f</a>)
  </li>
  <li>
    Paredit (Git repo last updated on 30 Nov 2019 with commit
    <a href="https://github.com/kovisoft/paredit/commits/d99905a">d99905a</a>)
  </li>
  <li>
    Rainbow Parentheses (Git repo last updated on 29 Oct 2015 with commit
    <a href="https://github.com/junegunn/rainbow_parentheses.vim/commits/27e7cd7">27e7cd7</a>)
  </li>
  <li>SBCL 1.4.16.debian</li>
  <li>GNU CLISP 2.49.92</li>
  <li>ECL 16.1.3</li>
  <li>MIT/GNU Scheme 9.1.1 on Debian GNU/Linux 9.11 (stretch)</li>
  <li>Clojure 1.10.1</li>
  <li>Quicklisp beta (libraries last updated on 30 Nov 2019)</li>
  <li>tmux 2.8</li>
</ul>
<p>
  You will probably need only a tiny subset of the tools above
  depending on which sections in this article you would follow.  Just
  pick the sections you want to try out and follow the steps written
  in them.  They will walk you through the procedure to install the
  tools applicable to the sections you have picked.  Regardless of
  which sections you pick, I recommend that you definitely go through
  the three "Get Started" subsections below.  These subsections go
  into detail about some of the prerequisites such as support for
  tmux, Paredit, support for Python interface in Vim, etc. that are
  not covered in the other sections.
</p>
<p>
  The choice of Debian may look like an odd one.  I want the commands
  and steps discussed in this article to be easily reproducible in a
  free and open source operating system.  Debian happens to be my
  favourite.  What works on Debian is easily reproducible on Ubuntu
  and other derivatives, often without any changes to the steps.  I
  believe, it will not be too difficult to translate the steps
  provided for Debian to the steps that would work on another
  operating system.
</p>
<p>
  Note that Quicklisp (a prerequisite for Vlime) is still beta
  software at the time of writing this article.  The actual steps to
  install Quicklisp may change in future.  Check
  <a href="https://www.quicklisp.org/">https://www.quicklisp.org/</a>
  for the most up-to-date instructions to install Quicklisp.
</p>
<h2 id="get-started">Get Started</h2>
<h3 id="get-started-with-slimv-and-sbcl">Get Started with Slimv and SBCL</h3>
<p>
  Here are the steps to set up Slimv and use it:
</p>
<ol>
  <li>
    <p>
      Install the tools required to set up a Common Lisp development
      environment with Slimv with this command:
    </p>
    <pre><code>sudo apt-get install vim-nox sbcl tmux git</code></pre>
    <p>
      The default Vim in Debian is <code>vim.basic</code> provided by
      the <code>vim</code> package which does not have support for
      Python interface.  Slimv is written in Vim script, Lisp, and
      Python 3, so it does need a Vim package that has support for
      Python interface.  One such package is <code>vim-nox</code> that
      provides the <code>vim.nox</code> command.  Installing it
      automatically updates the <code>vim</code> command to
      run <code>vim.nox</code>.  Another such package
      is <code>vim-gtk</code> which additionally provides GUI support.
      The graphical Vim known as GVim can be launched with
      the <code>gvim</code> command.  It runs in the desktop
      environment.  For the purpose of this article, I will stick
      to <code>vim-nox</code> because it is lightweight.  All steps
      meant for Slimv would run equally well on <code>vim-gtk</code>,
      MacVim, and GVim.
    </p>
    <p>
      Installing tmux is optional.  Slimv can launch Swank server
      automatically if Vim is running within tmux, GNU Screen, or a
      desktop environment, so if you are using GNU Screen already, you
      don't need to install tmux.  Also, if you are running Slimv in a
      desktop environment, you don't really need to install either
      tmux or GNU Screen, although you could if you would like to see
      Swank running in a separate tmux or GNU Screen window rather
      than a separate terminal window.  In this article, I am going to
      assume that Vim is running within tmux.
    </p>
    <p>
      If you are going to run Slimv in a terminal without a desktop
      environment, tmux, or GNU Screen, Swank server has to be run
      manually.  Point 4 below explains how to do it.
    </p>
  </li>
  <li>
    <p>
      Installing Slimv is pretty simple.  Here is one way to do it:
    </p>
<pre>
<code>git clone https://github.com/kovisoft/slimv.git ~/.vim/pack/plugins/start/slimv
vim +'helptags ~/.vim/pack/plugins/start/slimv/doc' +q</code>
</pre>
    <p>
      That is it!  Slimv is set up.  It's that straightforward.  The
      commands above show how to set up Slimv with just two shell
      commands.  You could also use a Vim plugin manager to install
      Slimv for you but I am not going to cover that here.
    </p>
  </li>
  <li>
    <p>
      This is an optional step.  Slimv supports starting Swank server
      automatically if you are running Vim in tmux, GNU Screen, or a
      desktop environment.  To start tmux, enter this command:
    </p>
    <pre><code>tmux</code></pre>
    <p>
      If you use GNU screen or a desktop environment, you don't have
      to run tmux.
    </p>
    <p>
      If you do not use tmux, GNU Screen, or a desktop environment,
      then you must start Swank server manually as explained in the
      next point.
    </p>
  </li>
  <li>
    <p>
      This step is necessary only if you are not using tmux, GNU
      Screen, or a desktop environment.  The following command shows
      how to start Swank server manually:
    </p>
    <pre><code>sbcl --load ~/.vim/pack/plugins/start/slimv/slime/start-swank.lisp</code></pre>
    <p>
      If you are using tmux, GNU Screen, or a desktop environment,
      Slimv can start Swank server automatically when needed and you
      don't need to perform this step.
    </p>
  </li>
  <li>
    <p>
      Create a new Lisp source code file, say, <code>foo.lisp</code>
      with this command:
    </p>
    <pre><code>vim foo.lisp</code></pre>
  </li>
  <li>
    <p>
      To connect to Swank server, enter the following command in
      normal mode:
    </p>
    <p>
      <kbd>,</kbd><kbd>c</kbd>
    </p>
    <p>
      If Vim is running within tmux, GNU Screen, or desktop
      environment, Slimv would automatically launch Swank server and
      connect to it.
    </p>
    <p>
      After Slimv connects to Swank successfully, Vim window should
      split into two and the following prompt should appear in the new
      split window:
    </p>
    <pre><samp>CL-USER&gt;</samp></pre>
    <p>
      This is the integrated REPL.  It is now alive and ready for
      interactive programming.
    </p>
    <p>
      We assume here that Slimv is using the default Slimv leader
      key <kbd>,</kbd>.  If you have overridden the Vim leader key,
      then the Slimv leader key might be same as the Vim leader key.
      Enter the command <code>:echo g:slimv_leader</code> in Vim
      command-line mode to find the leader key being used by Slimv.
    </p>
  </li>
  <li>
    <p>
      Type some code into the buffer for the new file.  To do so,
      first type <kbd>i</kbd> to enter insert mode and type this code:
    </p>
    <pre><code>(format t "hello, world~%")</code></pre>
    <p>
      Type <kbd>esc</kbd> to return to normal mode.
    </p>
  </li>
  <li>
    <p>
      To evaluate the current expression under the cursor, enter the
      following command in normal mode:
    </p>
    <p>
      <kbd>,</kbd><kbd>e</kbd>
    </p>
    <p>
      Both the current expression and its result should appear in the
      REPL window.
    </p>
  </li>
  <li>
    <p>
      The REPL is interactive.  Type
      <kbd>ctrl</kbd>+<kbd>w</kbd><kbd>w</kbd> to switch to the REPL
      window.  Then type <kbd>i</kbd> to enter insert mode and type
      this code:
    </p>
    <pre><code>(+ 1 2)</code></pre>
    <p>
      Type <kbd>enter</kbd> to evaluate the expression just like you
      would do in a real REPL.  The result should then appear in the
      REPL.
    </p>
    <p>
      Type <kbd>esc</kbd> to return to normal mode again.  Use the
      normal mode command
      <kbd>ctrl</kbd>&nbsp;+&nbsp;<kbd>w</kbd>&nbsp;<kbd>w</kbd> to
      switch between the split windows.
    </p>
  </li>
  <li>
    <p>
      Now that you have got started with Slimv, here is a brief note
      on uninstallation, in case you ever need it.  If Slimv is
      installed as described in point 2 above, enter the following
      command to uninstall it:
    </p>
    <pre><code>rm -rf ~/.vim/pack/plugins/start/slimv</code></pre>
  </li>
</ol>
<p>
  In steps 7 and 9, you may have noticed that as soon as you type an
  opening parenthesis or double quotation mark, a matching closing one
  is automatically inserted.  That is done by the
  <a href="https://github.com/kovisoft/paredit">Paredit</a> plugin
  which is bundled along with Slimv.  Paredit ensures structured
  editing of Lisp s-expressions and keeps all matched characters
  (parentheses, brackets, braces, quotes) balanced.  It also provides
  many new keybindings to edit s-expressions conveniently.  We will
  look into Paredit in a little more detail in
  the <a href="#get-started-with-paredit"><em>Get Started with
  Paredit</em></a> subsection later.
</p>
<h3 id="get-started-with-vlime-and-sbcl">Get Started with Vlime and SBCL</h3>
<p>
  Here are the steps to set up Vlime and use it:
</p>
<ol>
  <li>
    <p>
      Install the tools required to set up a Common Lisp development
      environment with Vlime with this command:
    </p>
    <pre><code>sudo apt-get install vim sbcl git curl</code></pre>
    <p>
      Note that unlike Slimv, Vlime can work with the default Vim in
      Debian, i.e., <code>vim.basic</code>.  Vlime does not require
      Vim with Python interface.
    </p>
  </li>
  <li>
    <p>
      Install Quicklisp with these commands:
    </p>
<pre>
<code>curl -O https://beta.quicklisp.org/quicklisp.lisp
sbcl --load quicklisp.lisp --eval '(quicklisp-quickstart:install)' --eval '(exit)'
sbcl --load ~/quicklisp/setup.lisp --eval '(ql:add-to-init-file)' --eval '(exit)'</code>
</pre>
    <p>
      Type <kbd>enter</kbd> in the end, when prompted, to complete the
      installation.
    </p>
  </li>
  <li>
    <p>
      Install Vlime and Paredit with these commands:
    </p>
<pre>
<code>git clone https://github.com/l04m33/vlime.git ~/.vim/bundle/vlime
git clone https://github.com/kovisoft/paredit ~/.vim/pack/plugins/start/paredit
echo 'set runtimepath^=~/.vim/bundle/vlime/vim' &gt;&gt; ~/.vimrc
vim +'helptags ~/.vim/bundle/vlime/vim/doc' +'helptags ~/.vim/pack/plugins/start/paredit/doc' +q</code>
</pre>
    <p>
      Unlike Slimv, Vlime does not bundle
      <a href="https://github.com/kovisoft/paredit">Paredit</a> along
      with itself.  As explained in the previous section, it helps us
      with structured editing of Lisp s-expressions.
    </p>
    <p>
      I recommend that you install Paredit but in case you choose not
      to, ensure that loading of filetype plugins is enabled by
      entering the <code>:filetype</code> command in command-line
      mode.  The output should contain <code>plugin:ON</code>.  If it
      is off, add the command <code>filetype plugin on</code>
      to <code>~/.vimrc</code> to ensure that this is always on.
      Vlime won't work without this being enabled.  If you install
      Paredit, you don't have to bother about this because Paredit
      takes care of enabling this by default.
    </p>
  </li>
  <li>
    <p>
      Create a new Lisp source code file, say, <code>foo.lisp</code>
      with this command:
    </p>
    <pre><code>vim foo.lisp</code></pre>
  </li>
  <li>
    <p>
      To start Vlime server (a wrapper around Swank server) and
      connect to it automatically, enter the following command in
      normal mode:
    </p>
    <p>
      <kbd>\</kbd><kbd>r</kbd><kbd>r</kbd>
    </p>
    <p>
      We assume here that Vim <code>&lt;LocalLeader&gt;</code> is left
      to its default, i.e., backslash.  If it is mapped to some other
      key combination, then that must be used instead of backslash in
      the above command.
    </p>
    <p>
      The first time this command is run after installing Vlime, it
      installs Swank server using Quicklisp.  Therefore, it can take a
      while for Vlime server to start the first time this command is
      run.  On subsequent use of these commands, it would start faster
      because it would be already installed.
    </p>
    <p>
      The console output from Vlime server is displayed in a split
      window.  After Vlime successfully connects to Swank, the
      following message is displayed at the bottom:
    </p>
    <pre><samp>Vlime Connection 1 established.</samp></pre>
    <p>
      After the above message appears, it is okay to close the split
      window for Vlime server by entering this command in Vim
      command-line mode:
    </p>
    <pre><code>:q</code></pre>
    <p>
      Vlime server would continue to run in background.  The following
      command can be used in normal mode to view the console output of
      Vlime server anytime it is required:
    </p>
    <p>
      <kbd>\</kbd><kbd>r</kbd><kbd>v</kbd>
    </p>
  </li>
  <li>
    <p>
      Type some code into the buffer for the new file.  To do so,
      first type <kbd>i</kbd> to enter insert mode and type this code:
    </p>
    <pre><code>(format t "hello, world~%")</code></pre>
    <p>
      Type <kbd>esc</kbd> to return to normal mode.
    </p>
  <li>
    <p>
      To evaluate, the current expression under the cursor, enter the
      following command in normal mode:
    </p>
    <p>
      <kbd>\</kbd><kbd>s</kbd><kbd>s</kbd>
    </p>
    <p>
      Both the current expression and its result should appear in the
      REPL window.
    </p>
    <p>
      Unlike Slimv, the REPL window of Vlime is <em>not</em>
      interactive.  Its <code>nomodifiable</code> option is set, so we
      cannot type code directly into the REPL window.  This can be a
      bit of a problem if we want to type arbitrary expressions into
      the REPL and execute them.  To mitigate this shortcoming to some
      extent, Vlime provides an alternative way to evaluate the
      current expression known as the interaction mode.  This is
      explained in the next point.
    </p>
  </li>
  <li>
    <p>
      Enable interaction mode by entering this command in normal mode:
    </p>
    <p><kbd>\</kbd><kbd>i</kbd></p>
    <p>
      The same command disables interaction mode, i.e., this command
      toggles the state of interaction mode between on and off.  When
      interaction mode is on, evaluate an expression under the cursor
      by simply pressing <kbd>enter</kbd> in normal mode.
    </p>
  </li>
  <li>
    <p>
      Now that you have got started with Vlime, here is a brief note
      on uninstallation, in case you ever need it.  If Quicklisp and
      Vlime are installed as described in the points 2 and 3 above,
      run these commands to uninstall them:
    </p>
<pre>
<code>rm -rf ~/quicklisp ~/.vim/bundle/vlime ~/.vim/pack/plugins/start/paredit
sed -i.bkp '/runtimepath.*vlime/d' ~/.vimrc</code>
</pre>
    <p>
      Optionally, remove <code>~/.sblrc</code> or edit it to remove
      the code pertaining to loading
      <code>quicklisp/setup.lisp</code>.
  </li>
</ol>
<h3 id="get-started-with-paredit">Get Started with Paredit</h3>
<p>
  You have already got started with Paredit when you wrote Lisp code
  while following one of the previous two subsections.  The moment you
  typed an opening parenthesis, Paredit inserted a closing one for you
  automatically.  Paredit keeps all matched characters such as
  parentheses, double quotes, etc. balanced when you edit code.  Here
  is a very brief exercise to quickly get started with some of the
  very basic features of Paredit:
</p>
<ol>
  <li>
    <p>
      Create a new Lisp source code file, say, <code>foo.lisp</code>
      with this command:
    </p>
    <pre><code>vim foo.lisp</code></pre>
  </li>
  <li>
    <p>
      Type <kbd>i</kbd> to enter insert mode and then type only this:
    </p>
    <pre><code>(defun square (x</code></pre>
    <p>
      At this point, Paredit should have inserted the two closing
      parentheses automatically.  The code should look like this:
    </p>
    <pre><code>(defun square (x<span class="cursor">)</span>)</code></pre>
    <p>
      The cursor should be situated just after the parameter
      <code>x</code>.  The block above shows where the cursor should
      be.
    </p>
  </li>
  <li>
    <p>
      While you are still in insert mode, type the first closing
      parenthesis.  Yes, type it even if the closing parenthesis is
      already present.  The cursor should now skip over the first
      closing parenthesis like this:
    </p>
    <pre><code>(defun square (x)<span class="cursor">)</span></code></pre>
    <p>
      Of course, there was no need to type the closing parenthesis
      because it was already present but typing it out to skip over it
      is more efficient than escaping to normal mode, then moving over
      it, and then entering insert mode again.  This is, in fact, a
      very nifty feature of Paredit.  We can enter code with the same
      keystrokes as we would without Paredit.
    </p>
  </li>
  <li>
    <p>
      You should still be in insert mode.  Type <kbd>enter</kbd> to
      create a new line below.  Now one of two things is going to
      happen.  If electric return is disabled, then a newline is
      inserted as expected like this:
    </p>
<pre>
<code>(defun square (x))
  <span class="cursor">)</span></code>
</pre>
    <p>
      If electric return is enabled, two newlines are inserted to
      create an empty line in between:
    </p>
<pre>
<code>(defun square (x)
  <span class="cursor"> </span>
  )</code>
</pre>
    <p>
      In both cases, indentation of two spaces is inserted
      automatically.  The new empty line inserted by electric return
      allows linewise editing of the code to be entered in this empty
      line.
    </p>
    <p>
      The electric return feature is enabled by default in both
      Paredit and Slimv.  It works by Paredit remapping the "enter"
      key (<code>&lt;CR&gt;</code>) in insert mode to a function that
      inserts electric return.  Slimv needs to remap the "enter" key
      to present the argument list of the current function but it
      takes care of performing an electric return before showing the
      argument list.  Vlime, however, forgets to perform electric
      return before showing the argument list, so this feature does
      not work in Vlime.
    </p>
    <p>
      For now, we will continue with the assumption that electric
      return is enabled and working fine.  If it is disabled or if it
      is not working for you, ignore the steps that discuss electric
      return.
    </p>
  </li>
  <li>
    <p>
      Now, type only this:
    </p>
    <pre><code>(* x x</code></pre>
    <p>
      Again, Paredit would have inserted the closing parenthesis
      automatically.  The code should look like this now:
    </p>
<pre>
<code>(defun square (x)
  (* x x<span class="cursor">)</span>
  )</code>
</pre>
  </li>
  <li>
    <p>
      Now, type one more closing parenthesis to advance past the
      automatically inserted closing parenthesis like this:
    </p>
<pre>
<code>(defun square (x)
  (* x x)<span class="cursor"> </span>
  )</code>
</pre>
  </li>
  <li>
    <p>
      Then type another closing parenthesis.  Paredit would now pick
      the lone closing parenthesis that is present in its own line and
      move it at the end of the current line like this:
    </p>
<pre>
<code>(defun square (x)
  (* x x))<span class="cursor"> </span></code>
</pre>
    <p>
      This behaviour of consuming the extra newline inserted by an
      electric return on typing a closing parenthesis helps the code
      to conform to the popular Lisp coding convention of putting all
      the consecutive closing parentheses next to each other in the
      same line.  In other words, typing closing parentheses
      re-gathers electric returns when applicable.
    </p>
  </li>
  <li>
    <p>
      Let us see what happens if we try to delete the opening
      parenthesis around the product function (the <code>*</code>
      function).  Type <kbd>esc</kbd> to return to normal mode.  Then
      enter <kbd>h</kbd> in normal mode to move the cursor one place
      left so that the cursor is placed on the parenthesis just after
      the last <code>x</code> in the code like this:
    </p>
<pre>
<code>(defun square (x)
  (* x x<span class="cursor">)</span>)</code>
</pre>
    <p>
      Type <kbd>x</kbd> to delete the closing parenthesis the cursor
      is on.  Nothing gets deleted!  Instead the cursor just skips
      over the parenthesis like this:
    </p>
<pre>
<code>(defun square (x)
  (* x x)<span class="cursor">)</span></code>
</pre>
    <p>
      Paredit refuses to delete the closing parenthesis because it
      encloses a non-empty list.  It would have deleted the closing
      parenthesis along with the opening one if the list were empty.
      This is Paredit trying to ensure that the s-expressions remain
      valid while editing.
    </p>
    <p>
      Note that in this step, <kbd>h</kbd> is a regular Vim motion
      command.  In Vim, by default, <kbd>x</kbd> deletes the character
      under the cursor, but when Paredit is enabled, it remaps this
      command to behave the way it did in this step to ensure that the
      parentheses remain balanced.
    </p>
  </li>
  <li>
    <p>
      Let us now try to delete the current line.  Type
      <kbd>d</kbd><kbd>d</kbd> to do so.  The result looks like this:
    </p>
<pre>
<code>(defun square (x)
  <span class="cursor">)</span></code>
</pre>
    <p>
      Note how the closing parenthesis has been left intact to keep
      the parentheses balanced.  Again, Paredit has remapped the
      <kbd>d</kbd><kbd>d</kbd> command to produce this behaviour.
    </p>
  </li>
  <li>
    <p>
      Now type <kbd>d</kbd><kbd>a</kbd><kbd>(</kbd> to delete the
      entire <code>defun</code> expression.  The buffer should look
      empty now.
    </p>
  </li>
  <li>
    <p>
      Type <kbd>i</kbd> to enter insert mode and type out the
      following code:
    </p>
    <pre><code>(list (* 10 20) (+ 30 40))<span class="cursor"> </span></code></pre>
  </li>
  <li>
    <p>
      Type <kbd>esc</kbd> to return to normal mode.
      Type <kbd>h</kbd><kbd>(</kbd><kbd>h</kbd><kbd>h</kbd> to place
      the cursor on the closing parenthesis of the first expression.
    </p>
    <pre><code>(list (* 10 20<span class="cursor">)</span> (+ 30 40))</code></pre>
    <p>
      Now type <kbd>,</kbd><kbd>&gt;</kbd>.  The closing parenthesis
      of the first expression moves right to <em>slurp</em> the next
      expression.  The buffer looks like this:
    </p>
    <pre><code>(list (* 10 20 (+ 30 40)<span class="cursor">)</span>)</code></pre>
    <p>
      We assume here that Paredit is using the default Paredit leader
      key <kbd>,</kbd>.  If you have overridden the Vim leader key,
      then the Paredit leader key might be same as the Vim leader key.
      Enter the command <code>:echo g:paredit_leader</code> in Vim
      command-line mode to find the leader key being used by Paredit.
    </p>
  </li>
  <li>
    <p>
      Now type <kbd>,</kbd><kbd>&lt;</kbd>.  The closing parenthesis
      of the outer expression moves left to <em>barf</em> the inner
      expression out.  The buffer looks like this again:
    </p>
    <pre><code>(list (* 10 20<span class="cursor">)</span> (+ 30 40))</code></pre>
    <p>
      While the cursor is on a parenthesis, the normal mode
      commands <code>,&lt;</code> or <code>,&gt;</code> can be used in
      this manner to move the parenthesis left or right, respectively,
      thereby slurping or barfing expressions.
    </p>
  </li>
</ol>
<p>
  That was a very brief overview of what Paredit can do.  There is a
  lot more to Paredit than what is described above.  Paredit has a
  rich set of keybindings to make editing s-expressions very
  convenient.  Enter <code>:help paredit-keys</code> in command-line
  mode to see the list of the keybindings.
</p>
<p>
  I think it is a good idea to read the entire Paredit documentation.
  Enter <code>:help paredit</code> to do so.  It is about 500 lines
  long and takes about 30 to 40 minutes to read.  The time spent
  reading this documentation is worth it because it makes editing Lisp
  code very pleasant and productive.
</p>
<h2 id="use-debugger-and-inspector">Use Debugger and Inspector</h2>
<p>
  After getting started with Slimv or Vlime, the very next thing you
  might want to know is how to work with the debugger.  The debugger
  window comes up whenever an error or an unhandled condition occurs.
  It might look quite scary to a beginner, so it is a good idea to
  become comfortable with it as soon as possible.  Fortunately, both
  Slimv and Vlime provide excellent key-bindings to inspect the error
  or dismiss it to return to the source code buffer quickly and
  easily.
</p>
<h3 id="use-debugger-and-inspector-with-slimv">Use Debugger and Inspector with Slimv</h3>
<p>
  The following steps trigger an error and then show how to work with
  the debugger in Slimv:
</p>
<ol>
  <li>
    <p>
      Create a file with Vim, say <code>foo.lisp</code> and enter the
      following code into it:
    </p>
<pre>
<code>(defun square (x)
  (* x x))

(square "foo")</code>
</pre>
  </li>
  <li>
    <p>
      Enter <kbd>,</kbd><kbd>b</kbd> to evaluate the buffer.
    </p>
  </li>
  <li>
    <p>
      As soon as the defective form <code>(square "foo")</code> gets
      evaluated, an error occurs.  The error, possible restarts, and
      the backtrace is displayed in a new split window for SLDB.  SLDB
      stands for Slime Debugger.  Here is an example of what may
      appear in the SLDB window:
    </p>
<pre>
<samp>The value
  "foo"
is not of type
  NUMBER
when binding SB-KERNEL::X
   [Condition of type TYPE-ERROR]

Restarts:
  0: [RETRY] Retry SLIME REPL evaluation request.
  1: [*ABORT] Return to SLIME's top level.
  2: [ABORT] abort thread (#&lt;THREAD "repl-thread" RUNNING {1003274E23}&gt;)

Backtrace:
  0: (SB-KERNEL:TWO-ARG-* "foo" "foo") [external]
  1: (SQUARE "foo")
  2: (SB-DEBUG::TRACE-CALL #&lt;SB-DEBUG::TRACE-INFO SQUARE&gt; #&lt;FUNCTION SQUARE&gt; "foo")
  3: (SB-INT:SIMPLE-EVAL-IN-LEXENV (SQUARE "foo") #&lt;NULL-LEXENV&gt;)
  4: (EVAL (SQUARE "foo"))
  5: (SWANK::EVAL-REGION "(defun square (x) ..)
  6: ((LAMBDA NIL :IN SWANK-REPL::REPL-EVAL))
  ...</samp>
</pre>
    <p>
      The ellipsis in the end is added by me to denote that the actual
      output has been truncated in this article for the sake of
      brevity.
    </p>
  </li>
  <li>
    <p>
      In the SLDB window, move the cursor to the second line of
      backtrace, i.e., on the following line:
    </p>
    <pre><samp>  1: (SQUARE "foo")</samp></pre>
    <p>
      Then type <kbd>enter</kbd>.  This line should now unfold to show
      the following details:
    </p>
<pre>
<samp>  1: (SQUARE "foo")
      in "(SB-INT:NAMED-LAMBDA SQUARE-----------------------------------
    Locals:
      X = "foo"</samp>
</pre>
  </li>
  <li>
    <p>
      Move the cursor to the line that begins with <code>in</code>,
      i.e., on this line:
    </p>
    <pre><samp>      in "(SB-INT:NAMED-LAMBDA SQUARE-----------------------------------</samp></pre>
    <p>
      Then type <kbd>enter</kbd>.  Some information about its source
      code should appear like this:
    </p>
<pre>
<samp>  1: (SQUARE "foo")
      in "(SB-INT:NAMED-LAMBDA SQUARE
    (X)
  (BLOCK SQUARE (#:***HERE*** (* X X))))" byte 1
    Locals:
      X = "foo"</samp>
</pre>
  </li>
  <li>
    <p>
      Move the cursor to the following line:
    </p>
    <pre><samp>      X = "foo"</samp></pre>
    <p>
      Then type <kbd>,</kbd><kbd>i</kbd> to inspect this variable.  A
      prompt would appear to confirm the variable name.  Type
      <kbd>enter</kbd> to confirm.  An inspector window should now
      appear with more details about this variable.  This window should
      look like this:
    </p>
<pre>
<samp>Inspecting #&lt;(SIMPLE-ARRAY CHARACTER (3)) {100478AFAF}>
--------------------
Press &lt;F1&gt; for Help

Dimensions: (3)
Element type: CHARACTER
Total size: 3
Adjustable: NIL
Fill pointer: NIL
Contents:
0: #\f
1: #\o
2: #\o


[&lt;&lt;] Exit Inspector</samp>
</pre>
  </li>
  <li>
    <p>
      Type <kbd>enter</kbd> to inspect any object under the cursor and
      drill down further.
    </p>
  </li>
  <li>
    <p>
      Type <kbd>backspace</kbd> in normal mode to return to the
      previous object.
    </p>
  </li>
  <li>
    <p>
      Enter <kbd>,</kbd><kbd>q</kbd> in normal mode to quit the
      inspector.
    </p>
  </li>
  <li>
    <p>
      Finally, move the cursor to the following line in the SLDB
      window:
    </p>
    <pre><samp>  1: [*ABORT] Return to SLIME's top level.</samp></pre>
    <p>
      Then type <kbd>enter</kbd> to execute this restart.
      Alternatively, enter <kbd>,</kbd><kbd>a</kbd> in normal mode to
      select the abort restart and quit to the previous level or
      <kbd>,</kbd><kbd>q</kbd> to quit to top level.
    </p>
  </li>
</ol>
<p>
  Most of the times when an error occurs, I quickly take a look at the
  stack trace to realise that I have made a silly mistake and enter
  the <kbd>,</kbd><kbd>q</kbd> command to abort and quit to top level.
  This can be quite convenient because it allows returning from
  debugging to coding very quickly with only two keystrokes.
</p>
<h3 id="use-debugger-and-inspector-with-vlime">Use Debugger and Inspector with Vlime</h3>
<p>
  The following steps trigger an error and then show how to work with
  the debugger in Vlime:
</p>
<ol>
  <li>
    <p>
      Create a file with Vim, say <code>foo.lisp</code> and enter the
      following code into it:
    </p>
<pre>
<code>(defun square (x)
  (* x x))

(square "foo")</code>
</pre>
  </li>
  <li>
    <p>
      Save the file, connect to Vlime server, and enter
      <kbd>\</kbd><kbd>o</kbd><kbd>f</kbd> in normal mode to compile
      the entire buffer.
    </p>
  </li>
  <li>
    <p>
      As soon as the defective form <code>(square "foo")</code> gets
      evaluated, an error occurs.  The error, possible restarts, and
      the backtrace is displayed in a new split window for SLDB.  SLDB
      stands for Slime Debugger.  Here is an example of what may
      appear in the SLDB window:
    </p>
<pre>
<samp>Thread: 1; Level: 1

The value
  "foo"
is not of type
  NUMBER
when binding SB-KERNEL::X
   [Condition of type TYPE-ERROR]

Restarts:
  0. *ABORT - Return to SLIME's top level.
  1.  ABORT - abort thread (#&lt;THREAD "worker" RUNNING {10045D6F83}&gt;)

Frames:
  0.  (SB-KERNEL:TWO-ARG-* "foo" "foo") [external]
  1.  (SQUARE "foo")
  2.  (SB-FASL::LOAD-FASL-GROUP #S(SB-FASL::FASL-INPUT :STREAM #&lt;SB-SYS:FD-STREAM for "file /home/susam/foo.fasl" {10045E76A3}&gt; :TABLE #(41 #&lt;PACKAGE "SB-IMPL"&gt; SB-IMPL::%DEFUN #&lt;PACKAGE "COMMON-LISP-USER"&gt;..
  3.  (SB-FASL::LOAD-AS-FASL #&lt;SB-SYS:FD-STREAM for "file /home/susam/foo.fasl" {10045E76A3}&gt; NIL NIL)
  4.  ((FLET SB-FASL::THUNK :IN LOAD))
  5.  (SB-FASL::CALL-WITH-LOAD-BINDINGS #&lt;CLOSURE (FLET SB-FASL::THUNK :IN LOAD) {7F7B9B0B60BB}&gt; #&lt;SB-SYS:FD-STREAM for "file /home/susam/foo.fasl" {10045E76A3}&gt;)
  ...</samp>
</pre>
    <p>
      The ellipsis in the end is added by me to denote that the actual
      output has been truncated in this article for the sake of
      brevity.
    </p>
  </li>
  <li>
    <p>
      In the SLDB window, move the cursor to the second line of
      backtrace, i.e., on the following line:
    </p>
    <pre><samp>  1.  (SQUARE "foo")</samp></pre>
    <p>
      Then type <kbd>d</kbd>.  A new split window should appear with
      the following details about this frame:
    </p>
<pre>
<samp>Frame: 1 (Restartable)

Locals:
  X: "foo"

Location:
  File: /home/susam/foo.lisp
  Position: 20
  Snippet:
    (* x x))

    (square "foo")</samp>
</pre>
  </li>
  <li>
	<p>
      While the cursor is on the same line as mentioned in the
      previous point, type <kbd>i</kbd> to bring up the inspector
      window for this frame.
	</p>
  </li>
  <li>
    <p>
      In the inspector window, type <kbd>i</kbd> to enter insert mode.
      Enter the following variable name in insert mode:
    </p>
    <pre><code>x</code></pre>
    <p>
      Then type <kbd>esc</kbd> to return to normal mode.  Then type
      <kbd>enter</kbd>.  The following details about the variable
      <code>x</code> should now appear in the inspector window:
    </p>
<pre>
<samp>#&lt;(SIMPLE-ARRAY CHARACTER (3)) {1004617ABF}>
============================================

Dimensions: (3)
Element type: CHARACTER
Total size: 3
Adjustable: NIL
Fill pointer: NIL
Contents:
0: #\f
1: #\o
2: #\o</samp></pre>
  </li>
  <li>
    <p>
      Type <kbd>enter</kbd> to inspect any object under the cursor and
      drill down further.
    </p>
  </li>
  <li>
    <p>
      Type <kbd>p</kbd> to return to the previous object.
    </p>
  </li>
  <li>
    <p>
      Enter the regular Vim command <code>:q</code> in command-line
      mode to quit the inspector window.
    </p>
  </li>
  <li>
    <p>
      Finally, move the cursor to the following line in the SLDB
      window:
    </p>
    <pre><samp>  1: [*ABORT] Return to SLIME's top level.</samp></pre>
    <p>
      Then type <kbd>enter</kbd> to execute this restart.
      Alternatively, we can enter <kbd>a</kbd> in normal mode to
      select the abort restart to return to the previous level.  At
      this time, there is no command to return to SLIME's top level.
    </p>
  </li>
</ol>
<h2 id="trace-function">Trace Function</h2>
<h3 id="trace-function-in-slimv">Trace Function in Slimv</h3>
<p>
  The following steps show how to get started with tracing functions
  in Slimv:
</p>
<ol>
  <li>
    <p>
      Create a file with Vim, say <code>foo.lisp</code> and enter the
      following code into it:
    </p>
<pre>
<code>(defun square (x)
  (* x x))

(square (square 2))</code>
</pre>
  </li>
  <li>
    <p>
      Enter <kbd>,</kbd><kbd>b</kbd> in normal mode to evaluate the
      entire buffer.
    </p>
  </li>
  <li>
    <p>
      Place the cursor on the function name, i.e., on
      <code>square</code>, and enter <kbd>,</kbd><kbd>t</kbd> in
      normal mode to toggle tracing for this function.  A prompt
      appears to confirm the function name.  Type <kbd>enter</kbd> to
      confirm.
    </p>
  </li>
  <li>
    <p>
      While the cursor is on the last expression, enter
      <kbd>,</kbd><kbd>d</kbd> in normal mode to evaluate the top-level
      form.  The following output appears in the REPL buffer.
    </p>
<pre>
<code>(square (square 2))
  0: (SQUARE 2)
  0: SQUARE returned 4
  0: (SQUARE 4)
  0: SQUARE returned 16
16</code>
</pre>
    <p>
      This output contains information about each call to the traced
      function, arguments passed to it, and the return values.
    </p>
  </li>
</ol>
<h3 id="trace-function-in-vlime">Trace Function in Vlime</h3>
<p>
  It takes a little more work to start tracing functions in Vlime.
  The following steps show how to do it:
</p>
<ol>
  <li>
    <p>
      Add the following statement to <code>~/.vimrc</code>:
    </p>
<pre>
<code>let g:vlime_contribs = ['SWANK-ASDF', 'SWANK-PACKAGE-FU',
                      \ 'SWANK-PRESENTATIONS', 'SWANK-FANCY-INSPECTOR',
                      \ 'SWANK-C-P-C', 'SWANK-ARGLISTS', 'SWANK-REPL',
                      \ 'SWANK-FUZZY', 'SWANK-TRACE-DIALOG']</code>
</pre>
    <p>
      The above variable defines the list of Swank contrib modules to
      load while initialising a Vlime connection.  All modules
      mentioned above except the last one are loaded by default.  The
      <code>SWANK-TRACE-DIALOG</code> module is not loaded by default
      but this module is necessary for tracing functions, so in order
      to load it, we define this variable to load this module in
      addition to all the other modules that are loaded by default.
    </p>
  </li>
  <li>
    <p>
      Create a file with Vim, say <code>foo.lisp</code> and enter the
      following code into it:
    </p>
<pre>
<code>(defun square (x)
  (* x x))

(square (square 2))</code>
</pre>
  </li>
  <li>
    <p>
      Save the file, connect to Vlime server, and enter
      <kbd>\</kbd><kbd>o</kbd><kbd>f</kbd> in normal mode to compile
      the entire buffer.
    </p>
  </li>
  <li>
    <p>
      Enter <kbd>\</kbd><kbd>T</kbd><kbd>D</kbd> in normal mode to
      show the trace dialog in a split window.
    </p>
  </li>
  <li>
    <p>
      Enter <kbd>ctrl</kbd>&nbsp;+&nbsp;<kbd>w</kbd>&nbsp;<kbd>w</kbd>
      in normal mode to go back to the source code window.
    </p>
  </li>
  <li>
    <p>
      Place the cursor on the function name, i.e., on
      <code>square</code>, and enter
      <kbd>\</kbd><kbd>T</kbd><kbd>T</kbd> in normal mode to toggle
      tracing for this function.
    </p>
  </li>
  <li>
    <p>
      While the cursor is on the last expression, enter
      <kbd>\</kbd><kbd>s</kbd><kbd>t</kbd> in normal mode to evaluate
      the top-level form.
    </p>
  </li>
  <li>
    <p>
      Enter <kbd>ctrl</kbd>&nbsp;+&nbsp;<kbd>w</kbd>&nbsp;<kbd>w</kbd>
      in normal mode twice to go to the trace window.
    </p>
  </li>
  <li>
    <p>
      Under <code>Trace Entries</code>, place the cursor on
      <code>[refresh]</code> and type <kbd>enter</kbd>.
    </p>
  </li>
  <li>
    <p>
      Then place the cursor on <code>[fetch next batch]</code> and
      type <kbd>enter</kbd>.  Two results should appear for the two
      <code>square</code> calls that were made due to step 7.  The trace
      information would be folded under each call.
    </p>
  </li>
  <li>
    <p>
      Move the cursor to each fold line and enter
      <kbd>z</kbd><kbd>o</kbd> in normal mode to open the fold.  After
      opening both the folds, the following result should be visible:
    </p>
    <pre>
<code>0 - COMMON-LISP-USER::SQUARE
    &gt; 2
    &lt; 4
1 - COMMON-LISP-USER::SQUARE
    &gt; 4
    &lt; 16
    16</code>
</pre>
    <p>
      The lines starting with <code>&gt;</code> show the arguments and
      the ones starting with <code>&lt;</code> show the return values.
    </p>
  </li>
</ol>
<h2 id="nifty-features">Nifty Features</h2>
<p>
  In this section, we will go over some of the nifty features that
  these plugins offer.  Not all features will be covered here.  I have
  chosen only a few features for the discussion here that I felt would
  be useful to beginners and at the same time also demonstrate the
  versatility of these plugins.
</p>
<h3 id="evaluate-top-level-form">Evaluate Top-Level Form</h3>
<p>
  In the previous sections, we saw how to evaluate the current
  expression under the cursor.  In this section, we will see how to
  evaluate the top-level expression around the current cursor
  position.  Let us do a small exercise to see this:
</p>
<ol>
  <li>
    <p>
      Create a file with Vim, say <code>foo.lisp</code> and enter the
      following code into it:
    </p>
    <pre><code>(+ 1 (* 2 (/ 6 <span class="cursor">2</span>)))</code></pre>
  </li>
  <li>
    <p>
      With Slimv or Vlime connected to Swank, let us do a quick recap
      of how to evaluate the current expression.
    </p>
    <p>
      With Slimv, enter the normal mode
      command <kbd>,</kbd><kbd>e</kbd> to evaluate the current
      expression.
    </p>
    <p>
      With Vlime, enter the normal mode command
      <kbd>\</kbd><kbd>s</kbd><kbd>s</kbd> to evaluate the current
      expression.
    </p>
    <p>
      The current expression, i.e., <code>(/ 6 2)</code> should get
      evaluated and the result <code>3</code> should appear in the
      REPL buffer.
    </p>
  </li>
  <li>
    <p>
      Let us now see how to evaluate the top-level expression.
    </p>
    <p>
      With Slimv, enter the normal mode
      command <kbd>,</kbd><kbd>d</kbd> to evaluate the top-level
      expression.
    </p>
    <p>
      With Vlime, enter the normal mode command
      <kbd>\</kbd><kbd>s</kbd><kbd>t</kbd> to evaluate the top-level
      expression.
    </p>
    <p>
      The top-level expression should get evaluated and the result
      <code>7</code> should appear in the REPL buffer.
    </p>
  </li>
</ol>
<h3 id="rainbow-parentheses">Rainbow Parentheses</h3>
<p>
  Rainbow parentheses make it easy to see matching parentheses by
  colouring different levels of parentheses with different colours.
  Matching parentheses have the same colour.  To enable this feature
  in Slimv, add this command to <code>~/.vimrc</code>:
</p>
<pre><code>let g:lisp_rainbow=1</code></pre>
<p>
  This feature is not available in Vlime.  But there are several Vim
  plugins that support rainbow parentheses.  Here are the steps to
  install one such plugin that is quite popular:
</p>
<pre>
<code>git clone https://github.com/junegunn/rainbow_parentheses.vim.git ~/.vim/pack/plugins/start/rainbow_parentheses
echo 'autocmd FileType lisp,scheme,clojure RainbowParentheses' &gt;&gt; ~/.vimrc</code>
</pre>
<p>
  In case you ever want to uninstall it, enter these commands:
</p>
<pre>
<code>rm -rf ~/.vim/pack/plugins/start/rainbow_parentheses
sed -i.bkp '/autocmd.*RainbowParentheses/d' ~/.vimrc</code>
</pre>
<h3 id="argument-list">Argument List</h3>
<p>
  You must have seen this feature already while trying out the
  sections earlier.  While editing a Lisp source file, after typing a
  function name, as soon as a space is typed or the enter key is
  typed, the argument list for the function appears to serve as a
  reference.  In Slimv, the argument list appears in the status line
  at the bottom.  In Vlime, the argument list appears in a split
  window at the top.
</p>
<h3 id="omni-completion">Omni-Completion</h3>
<p>
  Type a function name partially, e.g., <code>form</code>, and type
  <kbd>tab</kbd> while still in insert mode.  The omni-completion menu
  should appear with the list of completions if there are multiple
  choices.  Type <kbd>ctrl</kbd>+<kbd>n</kbd> to select the next choice
  and <kbd>ctrl</kbd>+<kbd>p</kbd> to select the previous choice.
  Selecting a choice also immediately inserts that choice in the
  buffer.  This works in both Slimv and Vlime.  In Slimv, we can also
  type <kbd>tab</kbd> to select the next choice.
</p>
<p>
  By default, omni-completion is fuzzy.  For example,
  type <code>wl</code> and type <kbd>tab</kbd> and omni-complete
  should insert <code>write-line</code> automatically as well as show
  other matching choices.
</p>
<h3 id="describe-symbol">Describe Symbol</h3>
<p>
  With Slimv, enter the normal mode command <kbd>,</kbd><kbd>s</kbd>
  to describe the symbol under the cursor.  This brings up the
  documentation of the symbol in the Vim message area.  This feature
  works while editing Common Lisp and Clojure source files but not
  while editing Scheme source file.  This feature is not supported for
  Scheme at this time.  See
  the <a href="#other-lisp-dialects"><em>Other Lisp Dialects</em></a>
  section for details on how to set up Slimv with Clojure and MIT/GNU
  Scheme.
</p>
<p>
  With Vlime, enter <kbd>\</kbd><kbd>d</kbd><kbd>a</kbd> in normal
  mode to describe the symbol under the cursor.  This brings up the
  documentation of the symbol in a split window.
</p>
<h3 id="expand-macro">Expand Macro</h3>
<p>
  Here is an excercise that shows how to expand macros interactively
  while editing a Lisp source file:
</p>
<ol>
  <li>
    <p>
      Create a file with Vim, say <code>foo.lisp</code> and enter the
      following code into it:
    </p>
<pre>
<code>(defmacro calc (a op b)
  (list op a b))

(defmacro square (x)
  (list 'calc x '* x))

(square 2)</code>
</pre>
  </li>
  <li>
    <p>
      With Slimv, enter <kbd>,</kbd><kbd>b</kbd> in normal mode to
      evaluate the entire buffer.
    </p>
    <p>
      With Vlime, save the file, connect to Vlime server, and type
      <kbd>\</kbd><kbd>o</kbd><kbd>f</kbd> in normal mode to compile the
      entire buffer.
    </p>
  </li>
  <li>
    <p>
      With Slimv, while the cursor is on the last expression, enter
      <kbd>,</kbd><kbd>1</kbd> in normal mode to expand the macro form
      once.
    </p>
    <p>
      With Vlime, enter <kbd>\</kbd><kbd>m</kbd><kbd>1</kbd> in normal
      mode to do the same thing.
    </p>
    <p>
      The following expansion should appear as the result:
    </p>
    <pre><code>(CALC 2 * 2)</code></pre>
    <p>
      Slimv displays the expansion in the REPL buffer whereas Vlime
      displays it in a new split window.
    </p>
  </li>
  <li>
    <p>
      With Slimv, enter <kbd>,</kbd><kbd>m</kbd> in normal mode to
      recursively expand the current expression until it is no longer
      a macro.
    </p>
    <p>
      With Vlime, enter <kbd>\</kbd><kbd>m</kbd><kbd>a</kbd> in normal
      mode to do the same thing.
    </p>
    <p>
      The following expansion should appear as the result:
    </p>
    <pre><code>(* 2 2)</code></pre>
  </li>
</ol>
<h3 id="cross-reference">Cross Reference</h3>
<p>
  Here is an exercise that shows how to use the cross-reference
  commands in Slimv and Vlime:
</p>
<ol>
  <li>
    <p>
      Create a file with Vim, say <code>foo.lisp</code> and enter the
      following code into it:
    </p>
<pre>
<code>(defun square (x)
  (* x x))

(defun square-of-sum (x y)
  (square (+ x y)))

(defun sum-of-squares (x y)
  (+ (square x) (square y)))

(square-of-sum 2 3)
(sum-of-squares 2 3)</code>
</pre>
  </li>
  <li>
    <p>
      With Slimv, enter <kbd>,</kbd><kbd>b</kbd> in normal mode to
      evaluate the entire buffer.
    </p>
    <p>
      With Vlime, save the file, connect to Vlime server, and type
      <kbd>\</kbd><kbd>o</kbd><kbd>f</kbd> in normal mode to compile the
      entire buffer.
    </p>
  </li>
  <li>
    <p>
      With Slimv, place the cursor on any occurrence of the symbol
      <code>square</code> and enter
      <kbd>,</kbd><kbd>x</kbd><kbd>l</kbd> in normal mode.  A prompt
      would appear to confirm the symbol name.  Type <kbd>enter</kbd>
      to confirm.  The list of all callers should now appear in the
      REPL buffer.
    </p>
    <p>
      With Vlime, place the cursor on any occurrence of the symbol
      <code>square</code> and enter <kbd>\</kbd><kbd>x</kbd><kbd>c</kbd>
      in normal mode to list all callers of the function.  The output
      appears in a split window containing the cross reference (xref)
      buffer.  Type <kbd>enter</kbd> on any item in the xref buffer and
      Vlime will take you directly to the referenced location.
    </p>
  </li>
</ol>
<h2 id="other-common-lisp-implementations">Other Common Lisp Implementations</h2>
<p>
  The previous sections used SBCL as the implementation of Common
  Lisp.  How well do Slimv and Vlime work with other Common Lisp
  implementations?
</p>
<p>
  I have found that both plugins are pretty well tested with SBCL.
  However, they may not be so well tested with other implementations.
  Due to the lack of sufficient testing with Common Lisp
  implementations other than SBCL, certain errors may occur while
  using other implementations.  Sometimes it is possible to work
  around these errors and sometimes it isn't.  We will see an example
  of this in an upcoming section when we try to start Swank server
  automatically using Vlime and CLISP.
</p>
<p>
  For this section, I choose CLISP and Embeddable Common-Lisp (ECL) as
  two other implementations of Common Lisp that will be used with
  Slimv and Vlime.  After following the upcoming subsections, you
  should get the hang of how to make Slimv or Vlime work with other
  implementations of Common Lisp.
</p>
<h3 id="use-slimv-with-clisp">Use Slimv with CLISP</h3>
<p>
  If you have read and tried the steps in the
  <a href="#get-started-with-slimv-and-sbcl"><em>Get Started with
  Slimv and SBCL</em></a> section, it is going to be quite easy to use
  Slimv with CLISP.  The steps are similar with a few minor
  modifications.  They are explained below:
</p>
<ol>
  <li>
    <p>
      Uninstall SBCL and install CLISP with these commands:
    </p>
    <pre>
<code>sudo apt-get remove sbcl
sudo apt-get install clisp</code></pre>
  </li>
  <li>
    <p>
      To start Swank server manually, enter this command:
    </p>
    <pre><code>clisp ~/.vim/pack/plugins/start/slimv/slime/start-swank.lisp</code></pre>
    <p>
      Then edit a Lisp source file and enter the normal command
      <kbd>,</kbd><kbd>c</kbd> to connect to it and bring up the REPL
      window.
    </p>
  </li>
  <li>
    <p>
      To start Swank automatically from Slimv, there is nothing more
      to be done.  Just edit a Lisp source file and enter the normal
      mode command <kbd>,</kbd><kbd>c</kbd>.  While running in GNU
      Screen, tmux, or a desktop environment, Slimv can automatically
      detect CLISP and start Swank server with it.
    </p>
  </li>
</ol>
<p>
  In general, to start Swank server manually with another Common Lisp
  implementation, we need to figure out how to load
  <code>start-swank.lisp</code> with it.
</p>
<h3 id="use-slimv-with-ecl">Use Slimv with ECL</h3>
<p>
  The steps to use Slimv with Embeddable Common-Lisp (ECL) are very
  similar too.  Once again, only if we need to start Swank server
  manually, we need to figure out the command to do so.  Otherwise,
  there is no other difference.  Here are the steps:
</p>
<ol>
  <li>
    <p>
      Ensure that SBCL and CLISP are uninstalled and ECL is installed.
    </p>
    <pre>
<code>sudo apt-get remove sbcl clisp
sudo apt-get install ecl</code></pre>
  </li>
  <li>
    <p>
      To start Swank server manually, enter this command:
    </p>
    <pre><code>ecl --load ~/.vim/pack/plugins/start/slimv/slime/start-swank.lisp</code></pre>
    <p>
      Then edit a Lisp source file and enter the normal command
      <kbd>,</kbd><kbd>c</kbd> to connect to it and bring up the REPL
      window.
    </p>
  </li>
  <li>
    <p>
      To start Swank automatically from Slimv, there is nothing more
      to be done.  Just edit a Lisp source file and enter the normal
      mode command <kbd>,</kbd><kbd>c</kbd>.  While running in GNU
      Screen, tmux, or a desktop environment, Slimv can automatically
      detect CLISP and start Swank server with it.
    </p>
    <p>
      There is a possible timeout issue to be aware of though.  ECL
      can take a minute or two to compile the code it loads the first
      time Swank server is started.  However, Slimv has a default
      timeout period of 20 seconds, so Slimv may fail with the
      following error message:
    </p>
    <pre><samp>SWANK server is not running.  Press ENTER to continue.</samp></pre>
    <p>
      If this happens, just wait for ECL to complete compiling Swank
      server.  Once it starts Swank server, enter the normal mode
      command <kbd>,</kbd><kbd>c</kbd> again and it should connect
      immediately.
    </p>
  </li>
</ol>
<h3 id="use-vlime-with-clisp">Use Vlime with CLISP</h3>
<p>
  This subsection assumes that you have already read and tried the
  <a href="#get-started-with-vlime-and-sbcl"><em>Get Started with
  Vlime and SBCL</em></a> section, so you are familiar with Vlime
  basics.  Now we will see what more it takes to use Vlime with CLISP
  in the steps below:
</p>
<ol>
  <li>
    <p>
      Let us assume we want to start afresh with CLISP, i.e., we do
      not have previous artifacts created by SBCL.  To clean up old
      artifacts, enter these commands:
    </p>
<pre>
<code>rm -rf ~/.sbclrc ~/quicklisp
sudo apt-get remove sbcl</code>
</pre>
  </li>
  <li>
    <p>
      Install CLISP with this command:
    </p>
    <pre><code>sudo apt-get install clisp</code></pre>
  </li>
  <li>
    <p>
      Install Quicklisp using CLISP with these commands:
    </p>
    <pre>
<code>curl -O https://beta.quicklisp.org/quicklisp.lisp
clisp -i quicklisp.lisp -x '(quicklisp-quickstart:install)'
clisp -i ~/quicklisp/setup.lisp -x '(ql:add-to-init-file)'</code>
</pre>
    <p>
      Type <kbd>enter</kbd> in the end, when prompted, to complete the
      installation.
    </p>
  </li>
  <li>
    <p>
      Add the following code to <code>~/.vimrc</code>:
    </p>
<pre>
<code>let g:vlime_cl_impl = 'clisp'
function! VlimeBuildServerCommandFor_clisp(vlime_loader, vlime_eval)
    return ['clisp', '-i', a:vlime_loader,
                   \ '-x', a:vlime_eval,
                   \ '-repl']
endfunction</code>
</pre>
    <p>
      Unlike Slimv, automatic start of Swank server with Common Lisp
      implementations other than SBCL are not supported out of the
      box, so the above Vim script tells Vlime how to start Swank
      server with CLISP.  The <code>-repl</code> option is used to
      work around an issue that is explained in the next point.
    </p>
  </li>
  <li>
    <p>
      Vlime is now ready to be used with CLISP.  Just edit a Lisp
      source file and enter the normal mode command
      <kbd>\</kbd><kbd>r</kbd><kbd>r</kbd> to start Swank server and
      connect to it automatically.
    </p>
    <p>
      You may see the following error in the SLIME debugger (`sldb`)
      split window:
    </p>
    <pre><samp>SOCKET-STATUS on #1=#&lt;INPUT STRING-INPUT-STREAM&gt; is illegal</samp></pre>
    <p>
      Despite the above error, the following message should appear at
      the bottom:
    </p>
    <pre><samp>Vlime Connection 1 established.</samp></pre>
    <p>
      If the above message occurs, you can ignore this error, close
      the debugger window as well as the console output window, and
      continue to use Vlime normally.
    </p>
    <p>
      The <code>-repl</code> option used in the previous step ensures
      that the REPL starts despite this error.  Without it, this step
      would not have succeeded.  This is what I meant when I said
      earlier that we may need to work around certain errors while
      using these plugins with a Common Lisp implementation other than
      SBCL.
    </p>
  </li>
</ol>
<h3 id="use-vlime-with-ecl">Use Vlime with ECL</h3>
<p>
  Here are the steps to use Vlime with ECL:
</p>
<ol>
  <li>
    <p>
      Let us assume we want to start afresh with ECL, i.e., we do not
      have previous artifacts created by SBCL or ECL.  To clean up old
      artifacts, enter these commands:
    </p>
<pre>
<code>rm -rf ~/.sbclrc ~/.clisprc.lisp ~/quicklisp
sudo apt-get remove sbcl clisp</code>
</pre>
  </li>
  <li>
    <p>
      Install ECL with this command:
    </p>
    <pre><code>sudo apt-get install ecl</code></pre>
  </li>
  <li>
    <p>
      Install Quicklisp using ECL with these commands:
    </p>
    <pre>
<code>curl -O https://beta.quicklisp.org/quicklisp.lisp
ecl --load quicklisp.lisp --eval '(quicklisp-quickstart:install)' --eval '(quit)'
ecl --load ~/quicklisp/setup.lisp --eval '(ql:add-to-init-file)' --eval '(quit)'</code>
</pre>
    <p>
      Type <kbd>enter</kbd> in the end, when prompted, to complete the
      installation.
    </p>
  </li>
  <li>
    <p>
      Add the following code to <code>~/.vimrc</code>:
    </p>
<pre>
<code>let g:vlime_cl_impl = 'ecl'
function! VlimeBuildServerCommandFor_ecl(vlime_loader, vlime_eval)
    return ['ecl', '--load', a:vlime_loader,
                 \ '--eval', a:vlime_eval]
endfunction</code>
</pre>
  </li>
  <li>
    <p>
      Edit a Lisp source file and enter the normal mode command
      <kbd>\</kbd><kbd>r</kbd><kbd>r</kbd> to start Swank server and
      connect to it automatically.
    </p>
  </li>
</ol>
<h2 id="other-lisp-dialects">Other Lisp Dialects</h2>
<p>
  So far, we have seen how to use Slimv or Vlime with a Common Lisp
  implementation.  Now let us see how well these plugins work with
  other Lisp dialects.  Vlime does not support other Lisp dialects.
  It supports Common Lisp only.  Slimv supports two other popular
  dialects of Lisp: Scheme and Clojure.  In the next two subsections,
  we see how
</p>
<h3 id="use-slimv-with-mit-gnu-scheme">Use Slimv with MIT/GNU Scheme</h3>
<p>
  Slimv is documented to work with MIT/GNU Scheme on Linux only.
  Enter
  <code>:help slimv-installation</code> in Vim to read more about it.
  It says the following under the "Prerequisites" section.
</p>
<blockquote>
  Lisp or Clojure or MIT/GNU Scheme (Linux only) installed.
</blockquote>
<p>
  Further, the Swank loader script for MIT/GNU Scheme named
  <code>swank-mit-scheme.scm</code> says the following in its source code
  comments:
</p>
<blockquote>
  You need MIT/GNU Scheme 9.2
</blockquote>
<p>
  At the time of writing this article, I have confirmed that both
  these requirements indeed need to be met to use Slimv with MIT/GNU
  Scheme.  Here are the steps to use Slimv with MIT/GNU Scheme:
</p>
<ol>
  <li>
    <p>
      Install MIT/GNU Scheme with this command:
    </p>
    <pre><code>sudo apt-get mit-scheme</code></pre>
    <p>
      Ensure that <code>vim-nox</code>, tmux, and Slimv are installed
      as explained in
      the <a href="#get-started-with-slimv-and-sbcl"><em>Get Started
      with Slimv and SBCL</em></a> subsection earlier.
    </p>
  </li>
  <li>
    <p>
      This is an optional step.  To start Swank server automatically
      from Slimv, run Vim in tmux, GNU Screen, or a desktop
      environment.  In this article, we use tmux, so start tmux with
      this command:
    </p>
    <pre><code>tmux</code></pre>
  </li>
  <li>
    <p>
      This step is necessary only if you are not using tmux, GNU
      Screen, or a desktop environment.  In such a case, enter this
      command to start Swank server manually:
    </p>
    <pre><code>scheme --load ~/.vim/pack/plugins/start/slimv/slime/contrib/swank-mit-scheme.scm</code></pre>
  </li>
  <li>
    <p>
      Create a new Scheme source code file, say, <code>foo.scm</code>
      with this command:
    </p>
    <pre><code>vim foo.scm</code></pre>
  </li>
  <li>
    <p>
      To connect to Swank server, enter the following command in Vim
      normal mode:
    </p>
    <p>
      <kbd>,</kbd><kbd>c</kbd>
    </p>
  </li>
  <li>
    <p>
      Type some code into the buffer for the new file.  To do so,
      first type <kbd>i</kbd> to enter insert mode and type this code:
    </p>
    <pre><code>(display "hello, world\n")</code></pre>
    <p>
      Type <kbd>esc</kbd> to return to normal mode.  To evaluate, the
      current expression under the cursor, enter the following command
      in normal mode:
    </p>
    <p>
      <kbd>,</kbd><kbd>e</kbd>
    </p>
    <p>
      Both the current expression and its result should appear in the
      REPL window.
    </p>
  </li>
</ol>
<p>
  I have confirmed that the steps above work fine with MIT/GNU Scheme
  9.1.1 on Debian GNU/Linux 9.11 (stretch).  Like I mentioned before,
  Slimv requires Linux to work with MIT/GNU Scheme.  For example,
  trying to start Swank server with MIT/GNU Scheme 9.2 on macOS High
  Sierra 10.13.6 fails with this error:
</p>
<pre>
<samp>; /usr/local/Cellar/mit-scheme/9.2_2/lib/mit-scheme-c/include/config.h:879:10:
fatal error: 'sys/types.h' file not found</samp>
</pre>
<p>
  Further, the version of MIT/GNU Scheme really needs to be 9.x.  For
  example, when I try to start Swank with MIT/GNU Scheme 10.1.5 on
  Debian GNU/Linux 10.1 (buster), the following error occurs:
</p>
<pre>
<samp>;The object #[package 12 (user)], passed as an argument to
->environment, is not an environment.</samp>
</pre>
<h3 id="use-slimv-with-clojure">Use Slimv with Clojure</h3>
<p>
  Slimv works fine with Clojure too.  However, it may have some
  trouble locating Clojure on the system if we attempt to start Swank
  server automatically with Clojure.  That is because where and how
  Clojure is installed varies from operating system to operating
  system and also depends on the installation procedure chosen to set
  up Clojure.
</p>
<p>
  On Unix-like systems, Slimv looks for JAR files that match the glob
  pattern <code>clojure*.jar</code> at paths that match the glob
  pattern <code>/usr/local/bin/*clojure*</code>
  and <code>~/*clojure</code>, in that order.  On Windows, it looks
  for the JAR files at directory paths that match the glob
  pattern <code>C:\*clojure*</code> and <code>C:\*clojure*\lib</code>.
  Additionally, Slimv also looks for the JAR files at the paths
  mentioned in the <code>PATH</code> environment variable.  There are
  a few more strategies too to locate Clojure but we will not get into
  that here.
</p>
<p>
  In this section, I will show how to build Clojure from source with
  Maven and install it at <code>~/clojure/clojure.jar</code>, a path
  Slimv can easily find, so installing it here would mean that the
  steps below would work everywhere regardless of the operating
  system.  If you are on Windows, install Clojure
  at <code>C:\clojure\clojure.jar</code> instead.
</p>
<p>
  Here are the steps to install Clojure at
  <code>~/clojure/clojure.jar</code> and use it with Slimv:
</p>
<ol>
  <li>
    <p>
      Choose one of the two sets of commands below to install Maven:
    </p>
<pre>
<code># On Debian, Ubuntu, etc.
sudo apt-get install maven

# On macOS
brew install openjdk maven
export JAVA_HOME=/usr/local/opt/openjdk
export PATH="$JAVA_HOME/bin:$PATH"</code>
</pre>
  </li>
  <li>
    <p>
      Enter these commands to install Clojure:
    </p>
<pre>
<code>git clone https://github.com/clojure/clojure.git ~/clojure
git -C ~/clojure checkout clojure-1.10.1
mvn -f ~/clojure/pom.xml -Plocal -Dmaven.test.skip=true package</code>
</pre>
  </li>
  <li>
    <p>
      Ensure that <code>vim-nox</code>, tmux, and Slimv are installed
      as explained in
      the <a href="#get-started-with-slimv-and-sbcl"><em>Get Started
      with Slimv and SBCL</em></a> subsection earlier.
    </p>
  </li>
  <li>
    <p>
      This is an optional step.  To start Swank server automatically
      from Slimv, run Vim in tmux, GNU Screen, or a desktop
      environment.  In this article, we use tmux, so start tmux with
      this command:
    </p>
    <pre><code>tmux</code></pre>
  </li>
  <li>
    <p>
      This step is necessary only if you are not using tmux, GNU
      Screen, or a desktop environment.  In such a case, enter these
      commands to start Swank server manually:
    </p>
<pre>
<code>SWANK_DIR=~/.vim/pack/plugins/start/slimv/swank-clojure
java -cp "$HOME/clojure/clojure.jar:$SWANK_DIR" clojure.main -i "$SWANK_DIR/swank/swank.clj" -e '(swank.swank/start-repl)' -r</code>
</pre>
  </li>
  <li>
    <p>
      Create a new Clojure source code file, say, <code>foo.clj</code>
      with this command:
    </p>
    <pre><code>vim foo.clj</code></pre>
  </li>
  <li>
    <p>
      To connect to Swank server, enter the following command in Vim
      normal mode:
    </p>
    <p>
      <kbd>,</kbd><kbd>c</kbd>
    </p>
  </li>
  <li>
    <p>
      Type some code into the buffer for the new file.  To do so,
      first type <kbd>i</kbd> to enter insert mode and type this code:
    </p>
<pre><code>(println "hello, world")</code></pre>
    <p>
      Type <kbd>esc</kbd> to return to normal mode.  To evaluate, the
      current expression under the cursor, enter the following command
      in normal mode:
    </p>
    <p>
      <kbd>,</kbd><kbd>e</kbd>
    </p>
    <p>
      Both the current expression and its result should appear in the
      REPL window.
    </p>
  </li>
</ol>
<h2 id="comparison-of-slimv-and-vlime">Comparison of Slimv and Vlime</h2>
<p>
  Finally, let me provide a comparison of both Slimv and Vlime side by
  side.  This comparison table below is not exhaustive.  There are
  more differences between the tools than what is mentioned below.
</p>
<table class="grid top">
  <thead>
    <tr>
      <th>Slimv</th>
      <th>Vlime</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="width: 50%">
        <p>
          Slimv's directory structure conforms to the directory
          structure of plugins in a Vim package as well as the default
          directory structure expected by popular Vim plugin managers,
          so installing Slimv is quite straightforward.
        </p>
      </td>
      <td style="width: 50%">
        <p>
          Vlime's directory structure does not conform to the
          directory structure of plugins in a Vim package or the
          default directory structure expected by popular Vim plugin
          managers.  As a result, Vim's native support for packages
          cannot be used to install Vlime.  Installing it via a plugin
          manager requires fiddling with
          Vim's <code>runtimepath</code> option in order to load it
          successfully.
        </p>
      </td>
    </tr>
    <tr>
      <td style="width: 50%">
        <p>
          Slimv requires a Vim package that is compiled with support
          for Python interface.
        </p>
      </td>
      <td style="width: 50%">
        <p>
          Vlime does not have this requirement.  It can work with
          basic Vim that does not have Python interface.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <p>
          Slimv requires Vim to be running within tmux, GNU Screen, or
          a desktop environment to be able to start Swank server
          automatically.  If you have none of these, Swank server
          needs to be started manually.
        </p>
      </td>
      <td>
        <p>
          Vlime does not require tmux, GNU Screen, or a desktop
          environment in order to start Vlime server automatically.
          It can start Vlime server on its own.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <p>
          Slimv does not require Quicklisp to install Swank.  Slimv
          bundles the Swank server code with itself.
        </p>
      </td>
      <td>
        <p>
          Vlime requires Quicklisp to be installed.  It relies on
          Quicklisp to install Swank the first time it is needed.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <p>
          Slimv bundles Paredit with itself.  Installing Slimv also
          provides Paredit.
        </p>
      </td>
      <td>
        <p>
          Vlime does not bundle Paredit with itself.  Paredit needs to
          be installed separately.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <p>
          The buffer for REPL is interactive in Slimv.  We can type
          code directly into the REPL window and type <kbd>enter</kbd>
          to execute it.
        </p>
      </td>
      <td>
        <p>
          The buffer for REPL is not interactive in Vlime.  Its
          <code>nomodifiable</code> option is set, so we cannot type
          code directly into the REPL window.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <p>
          Paredit electric returns work fine with Slimv.  Slimv remaps
          the "enter" key to show argument list of the current
          function after inserting electric returns.  It takes care of
          preserving the electric return functionality of Paredit.
        </p>
      </td>
      <td>
        <p>
          Paredit electric returns do not work fine with Vlime.  Vlime
          remaps the "enter" key to show argument list of the current
          function without inserting electric returns.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <p>
          Slimv shows argument list of a function, symbol description,
          etc. in the status line or message area at the bottom.
        </p>
      </td>
      <td>
        <p>
          Vlime shows argument list of a function, symbol description,
          etc. in separate split windows.  These are extra windows to
          skip over while cycling between windows with the normal mode
          <kbd>ctrl</kbd>&nbsp;+&nbsp;<kbd>w</kbd>&nbsp;<kbd>w</kbd>
          command which could feel inconvenient.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <p>
          Slimv shows trace results, macro expansion, cross reference,
          etc. in the REPL buffer.
        </p>
      </td>
      <td>
        <p>
          Vlime shows resultions of trace results, macro expansion,
          cross reference, etc. in split windows.  These are extra
          windows to skip over while cycling between windows.  This
          could feel inconvenient.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <p>
          Slimv supports programming in Common Lisp, MIT/GNU Scheme,
          and Clojure.
        </p>
      </td>
      <td>
        <p>
          Vlime supports programming in Common Lisp only.  It does not
          support Scheme or Clojure.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <p>
          Slimv supports rainbow parentheses by adding
          <code>let g:lisp_rainbow=1</code> to <code>~/.vimrc</code>.
          With this feature, parentheses at different levels have
          different colours and matching parentheses have the same
          colour.
        </p>
      </td>
      <td>
        <p>
          Vlime does not have rainbow parentheses.  However, this is
          not a major problem because there are several independent
          plugins available that provide rainbow parentheses.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <p>
          Slimv cross-reference commands do not help us to jump
          directly to a function listed in the results.
        </p>
      </td>
      <td>
        <p>
          Vlime cross-reference commands create a xref buffer that
          allows us to jump directly to a function listed in the
          results by moving the cursor to the function name in the
          xref buffer and typing <code>enter</code>.
        </p>
      </td>
    </tr>
  </tbody>
</table>
<h2 id="quick-recommendation">Quick Recommendation</h2>
<p>
  If you are looking for a quick recommendation on which plugin to
  use, I am going to recommend Slimv.  It has been around for much
  longer.  It supports a wider variety of Lisp implementations.  I
  find its default key bindings more convenient.  A truly interactive
  REPL buffer is also a bonus.  Also, Slimv supports Scheme and
  Clojure whereas Vlime does not.  Having said that, I think it is a
  good idea to try out both the plugins on your own and then find out
  which one suits you more.
</p>
<h2 id="disclosure">Disclosure</h2>
<p>
  Four bugs were harmed while writing this article!
</p>
<p>
  While writing this article, I found the following four bugs in Slimv
  which were then promptly squashed:
  <a href="https://github.com/kovisoft/slimv/pull/87">#87</a>,
  <a href="https://github.com/kovisoft/slimv/pull/88">#88</a>,
  <a href="https://github.com/kovisoft/slimv/pull/89">#89</a>, and
  <a href="https://github.com/kovisoft/slimv/pull/90">#90</a>.
</p>
<h2 id="references">References</h2>
<ul>
  <li>
    <a href="https://web.archive.org/web/20160303225220/http://osdir.com/ml/lisp.cmucl.devel/2003-08/msg00302.html">Couple of Emacs hacks</a>
  </li>
  <li>
    <a href="https://groups.google.com/forum/#!topic/vim_announce/EKTuhjF3ET0">Vim 8.0 Released</a>
  </li>
  <li>
    <a href="https://kovisoft.github.io/slimv-tutorial/tutorial.html">Slimv Tutorial</a>
  </li>
  <li>
    <a href="https://github.com/l04m33/vlime/blob/master/vim/doc/vlime-tutor.txt">A Tutorial for Vlime</a>
  </li>
</ul>
