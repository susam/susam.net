<!-- title: Boot Quine -->
<!-- tag: ASM Programming DOS Technology -->
<p>
  I wrote a tiny 32-byte program composed of pure x86 machine code
  that writes itself to video memory when executed from the boot sector:
</p>
<pre><code>ea 05 7c 00 00 fc b8 00 b8 8e c0 8c c8 8e d8 31
ff be 00 7c b9 20 00 b4 0a ac ab e2 fc f4 eb fd</code></pre>
<p>
  We can create a boot image that contains these bytes, write it to
  the boot sector of a drive and boot an IBM PC compatible computer
  with it and it should print these 32 bytes on the screen.
</p>
<h1 id="demo">Demo</h1>
<p>
  On a Unix or Linux system, the following commands demonstrate how to
  create a boot image with the above program:
</p>
<pre>
<code>echo ea 05 7c 00 00 fc b8 00 b8 8e c0 8c c8 8e d8 31 | xxd -r -p > boot.img
echo ff be 00 7c b9 20 00 b4 0a ac ab e2 fc f4 eb fd | xxd -r -p >> boot.img
echo 55 aa | xxd -r -p | dd seek=510 bs=1 of=boot.img</code>
</pre>
<p>
  Now we can test this boot image using DOSBox with the following command:
</p>
<pre><code>dosbox -c cls -c 'boot boot.img'</code></pre>
<p>
  We can also test this image using QEMU x86 system emulator as follows:
</p>
<pre><code>qemu-system-i386 -fda boot.img</code></pre>
<p>
  We could also write this image to the boot sector of an actual
  physical storage device, such as a USB flash drive, and then boot
  the computer with it. Here is an example command that writes the
  boot image to the drive represented by the device
  path <code>/dev/sdx</code>.
</p>
<pre><code>cp a.img /dev/sdx</code></pre>
<p>
  <em>
    CAUTION: You need to be absolutely sure of the device path of the
    device being written to. The device path <code>/dev/sdx</code> is
    only an example here. If the boot image is written to the wrong
    device, access to the data on that would be lost.
  </em>
</p>
<p>
  On testing this boot image with an emulator or a real computer, the
  output should look approximately like this:
</p>
<pre><samp>&#x3A9;&#x2663;&#x7C;&#x20;&#x20;&#x207F;&#x2555;&#x20;&#x2555;&#xC4;&#x2514;&#xEE;&#x255A;&#xC4;&#x256A;&#x31;&#xA0;&#x255B;&#x20;&#x7C;&#x2563;&#x20;&#x20;&#x2524;&#x25D9;&#xBC;&#xBD;&#x393;&#x207F;&#x2320;&#x3B4;&#xB2;</samp></pre>
<p>
  This looks like gibberish, however every symbol in the above output
  corresponds to a byte of the program mentioned earlier. For example,
  the first symbol (omega) represents the byte value 0xea, the second
  symbol (club) represents the byte value 0x05, and so on. Here is a
  chart that approximates the symbol for every byte value with a
  Unicode symbol: <a href="../maze/cp437/cp437.html">cp437.html</a>.
</p>
<h2 id="disassembly">Disassembly</h2>
<p>
  We will now take a closer look at what the program introduced
  earlier does. Here is the disassembly of the program:
</p>
<pre>
<samp>$ <kbd>ndisasm -o 0x7c00 boot.img</kbd>
00007C00  EA057C0000        jmp 0x0:0x7c05
00007C05  FC                cld
00007C06  B800B8            mov ax,0xb800
00007C09  8EC0              mov es,ax
00007C0B  8CC8              mov ax,cs
00007C0D  8ED8              mov ds,ax
00007C0F  31FF              xor di,di
00007C11  BE007C            mov si,0x7c00
00007C14  B92000            mov cx,0x20
00007C17  B40A              mov ah,0xa
00007C19  AC                lodsb
00007C1A  AB                stosw
00007C1B  E2FC              loop 0x7c19
00007C1D  F4                hlt
00007C1E  EBFD              jmp short 0x7c1d
00007C20  0000              add [bx+si],al
00007C22  0000              add [bx+si],al
...
</pre>
<p>
  The ellipsis in the end represents the remainder of the bytes that
  contains zeroes and the boot sector magic bytes 0x55 and 0xaa in the
  end. We have omitted them here for the sake of brevity.
</p>
<p>
  When a computer boots, the BIOS reads the boot sector code from the
  first sector of the boot device into the memory at physical address
  0x7c00 and jumps to this address. Most BIOS implementations jump to
  0x0000:0x7c00 but there are some implementations that jump to
  0x07c0:0x0000 instead. Both these jumps are jumps to the same
  physical address 0x7c00 but this difference poses a problem for us
  because the offsets in our program depend on which jump the BIOS
  executed. In order to ensure that our program can run with both
  types of BIOS implementations, we use a popular trick of having the
  first instruction of our program execute a jump to address
  0x0000:0x7c05 in order to reach the second instruction. This sets
  the register CS to 0 and IP to 0x7c05 and we don't have to worry
  about the differences between BIOS implementations anymore. We can
  now pretend as if a BIOS implementation that jumps to 0x0000:0x7c00
  is going to load our program and write all the offsets accordingly.
</p>
<p>
  The <code>cld</code> instruction ensures that the direction flag is
  cleared. This will ensure that the <code>lodsb</code>
  and <code>stosw</code> instructions that come later increment the SI
  and DI registers after each operation. Then we set ES and DI to
  0xb800 and 0x0000, respectively. Thus ES:DI points to the start of
  the video memory at 0xb800:0x0000. We also set DS to the current
  value of CS and SI to 0x7c00. Thus DS:SI points to the top of our
  program in memory. Then we set the loop counter CX to 0x20 (decimal
  32) because we have 32 bytes of program to copy to video memory. The
  value 0xa (binary 00001010) in AH is used as the colour attribute of
  the text we will write to video memory a few instructions later. The
  higher nibble (binary 0000) represents black background colour and
  the lower nibble (binary 1010) represents bright green foreground
  colour.
</p>
<p>
  The loop between offsets 0x7c19 and 0x7c1a copy each byte of the
  program to video memory. The <code>lodsb</code> instruction loads a
  byte of the program from the memory address specified by DS:SI into
  AL and increments SI by 1. Note that AH is already set to 0xa. So
  the register AX contains the byte we want to print in its lower byte
  and its colour attribute in the higher byte. The <code>stosw</code>
  copies the value in AX to the memory address specified by ES:DI and
  increments DI by 2. This loop iterates 32 times and copies 32 bytes
  of the program to video memory.
</p>
<h2 id="separating-executable-bytes-and-data-bytes">Separating Executable Bytes and Data Bytes</h2>
<p>
  If you feel uncomfortable about calling the above program a quine
  because it reads its own bytes from the memory, we could have the
  program read the bytes it needs to print from a separate place in
  memory. We do not execute these bytes. We only read them and copy
  them to video memory. The following 76-byte program does this:
</p>
<pre>
<code>ea 05 7c 00 00 fc bb 02 00 b8 00 b8 8e c0 8c c8
8e d8 31 ff be 26 7c b9 26 00 b4 0a ac ab e2 fc
4b 75 f1 f4 eb fd ea 05 7c 00 00 fc bb 02 00 b8
00 b8 8e c0 8c c8 8e d8 31 ff be 26 7c b9 26 00
b4 0a ac ab e2 fc 4b 75 f1 f4 eb fd</code>
</pre>
<p>
  Here is how we can create a boot image with this:
</p>
<pre>
<code>echo ea 05 7c 00 00 fc bb 02 00 b8 00 b8 8e c0 8c c8 | xxd -r -p > boot.img
echo 8e d8 31 ff be 26 7c b9 26 00 b4 0a ac ab e2 fc | xxd -r -p >> boot.img
echo 4b 75 f1 f4 eb fd ea 05 7c 00 00 fc bb 02 00 b8 | xxd -r -p >> boot.img
echo 00 b8 8e c0 8c c8 8e d8 31 ff be 26 7c b9 26 00 | xxd -r -p >> boot.img
echo b4 0a ac ab e2 fc 4b 75 f1 f4 eb fd | xxd -r -p >> boot.img
echo 55 aa | xxd -r -p | dd seek=510 bs=1 of=boot.img</code>
</pre>
<p>
  Here are the commands to test this boot image:
</p>
<pre><code>dosbox -c cls -c 'boot boot.img'
qemu-system-i386 -fda boot.img</code></pre>
<p>
  The output should look like this:
</p>
<pre><samp>&#x3A9;&#x2663;&#x7C;&#x20;&#x20;&#x207F;&#x2557;&#x263B;&#x20;&#x2555;&#x20;&#x2555;&#xC4;&#x2514;&#xEE;&#x255A;&#xC4;&#x256A;&#x31;&#xA0;&#x255B;&#x26;&#x7C;&#x2563;&#x26;&#x20;&#x2524;&#x25D9;&#xBC;&#xBD;&#x393;&#x207F;&#x4B;&#x75;&#xB1;&#x2320;&#x3B4;&#xB2;&#x3A9;&#x2663;&#x7C;&#x20;&#x20;&#x207F;&#x2557;&#x263B;&#x20;&#x2555;&#x20;&#x2555;&#xC4;&#x2514;&#xEE;&#x255A;&#xC4;&#x256A;&#x31;&#xA0;&#x255B;&#x26;&#x7C;&#x2563;&#x26;&#x20;&#x2524;&#x25D9;&#xBC;&#xBD;&#x393;&#x207F;&#x4B;&#x75;&#xB1;&#x2320;&#x3B4;&#xB2;</samp></pre>
<p>
  Here is the disassembly of this program:
</p>
<pre>
<samp>$ <kbd>ndisasm -o 0x7c00 boot.img</kbd>
00007C00  EA057C0000        jmp 0x0:0x7c05
00007C05  FC                cld
00007C06  BB0200            mov bx,0x2
00007C09  B800B8            mov ax,0xb800
00007C0C  8EC0              mov es,ax
00007C0E  8CC8              mov ax,cs
00007C10  8ED8              mov ds,ax
00007C12  31FF              xor di,di
00007C14  BE267C            mov si,0x7c26
00007C17  B92600            mov cx,0x26
00007C1A  B40A              mov ah,0xa
00007C1C  AC                lodsb
00007C1D  AB                stosw
00007C1E  E2FC              loop 0x7c1c
00007C20  4B                dec bx
00007C21  75F1              jnz 0x7c14
00007C23  F4                hlt
00007C24  EBFD              jmp short 0x7c23
00007C26  EA057C0000        jmp 0x0:0x7c05
00007C2B  FC                cld
00007C2C  BB0200            mov bx,0x2
00007C2F  B800B8            mov ax,0xb800
00007C32  8EC0              mov es,ax
00007C34  8CC8              mov ax,cs
00007C36  8ED8              mov ds,ax
00007C38  31FF              xor di,di
00007C3A  BE267C            mov si,0x7c26
00007C3D  B92600            mov cx,0x26
00007C40  B40A              mov ah,0xa
00007C42  AC                lodsb
00007C43  AB                stosw
00007C44  E2FC              loop 0x7c42
00007C46  4B                dec bx
00007C47  75F1              jnz 0x7c3a
00007C49  F4                hlt
00007C4A  EBFD              jmp short 0x7c49
00007C4C  0000              add [bx+si],al
00007C4E  0000              add [bx+si],al
...</samp></pre>
<p>
  This program has two identical halves. The first half from offset
  0x7c00 to offset 0x7c25 are executable bytes. The second half from
  offset 0x7c26 to 0x7c4b are the data bytes read by the executable
  bytes. The executable part of the code has an outer loop that uses
  the register BX as the counter variable. It sets BX to 2 so that the
  outer loop iterates twice. In each iteration, it reads data bytes
  from the second half of the program and prints them. The code to
  read bytes and print them is very similar to our earlier program.
  Since the data bytes in the second half are identical to the
  executable bytes in the first half, printing the data bytes amounts
  to printing all bytes of the program.
</p>
<p>
  While this program does avoid reading the bytes that the CPU
  executes, the data bytes look exactly like the executable bytes.
  This shows that while writing quines in machine code, the lines
  between code and data are blurred. So I am not sure if there is any
  point in trying to avoid reading executable bytes in a machine code
  quine. Nevertheless, this program serves as an example of a
  self-printing program that does not execute the bytes it reads.
</p>
